<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>⚔️ War Territory - RTS Online</title>
    <script src="/socket.io/socket.io.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #00f2fe;
            --secondary: #4facfe;
            --accent: #f093fb;
            --danger: #ff6b6b;
            --success: #4ecdc4;
            --warning: #ffd93d;
            --dark-bg: #0a0a1a;
            --panel-bg: rgba(15, 15, 35, 0.95);
            --border-glow: rgba(0, 242, 254, 0.3);
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Rajdhani', 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a1a 100%);
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }
        
        /* ==================== ANIMATIONS GLOBALES ==================== */
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px var(--primary), 0 0 10px var(--primary), 0 0 15px transparent; }
            50% { box-shadow: 0 0 10px var(--primary), 0 0 20px var(--primary), 0 0 30px var(--primary); }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }
        
        @keyframes slideInLeft {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes fadeInUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes shimmer {
            0% { background-position: -200% center; }
            100% { background-position: 200% center; }
        }
        
        @keyframes borderGlow {
            0%, 100% { border-color: var(--primary); }
            50% { border-color: var(--secondary); }
        }
        
        /* ==================== MODAL DE CONNEXION ==================== */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(20,20,40,0.9) 0%, rgba(0,0,0,0.98) 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }
        
        .modal-content {
            background: linear-gradient(145deg, rgba(30,30,60,0.95), rgba(15,15,35,0.98));
            padding: 50px;
            border-radius: 25px;
            text-align: center;
            border: 2px solid var(--glass-border);
            box-shadow: 
                0 25px 80px rgba(0,0,0,0.6),
                0 0 60px rgba(0, 242, 254, 0.1),
                inset 0 1px 0 rgba(255,255,255,0.1);
            animation: fadeInUp 0.5s ease-out;
            position: relative;
            overflow: hidden;
        }
        
        .modal-content::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, var(--primary), transparent 30%);
            animation: rotate 4s linear infinite;
            opacity: 0.1;
        }
        
        @keyframes rotate {
            to { transform: rotate(360deg); }
        }
        
        .modal-content h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 52px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, var(--primary), var(--accent), var(--secondary));
            background-size: 200% auto;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shimmer 3s linear infinite;
            text-shadow: 0 0 30px rgba(0, 242, 254, 0.5);
            position: relative;
            z-index: 1;
        }
        
        .modal-content h2 {
            color: #666;
            margin-bottom: 35px;
            font-weight: 400;
            font-size: 18px;
            position: relative;
            z-index: 1;
        }
        
        .modal-content input {
            width: 320px;
            padding: 18px 25px;
            font-size: 18px;
            border: 2px solid var(--glass-border);
            border-radius: 15px;
            background: rgba(0,0,0,0.4);
            color: white;
            outline: none;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            position: relative;
            z-index: 1;
        }
        
        .modal-content input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 20px rgba(0, 242, 254, 0.3);
            background: rgba(0, 242, 254, 0.05);
        }
        
        .modal-content input::placeholder {
            color: #555;
        }
        
        .modal-content button {
            width: 320px;
            padding: 18px;
            font-size: 20px;
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border: none;
            border-radius: 15px;
            color: #0a0a1a;
            cursor: pointer;
            font-weight: 700;
            transition: all 0.3s ease;
            position: relative;
            z-index: 1;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .modal-content button:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 15px 40px rgba(0, 242, 254, 0.4);
        }
        
        .modal-content button:active {
            transform: translateY(0) scale(0.98);
        }
        
        .hidden { display: none !important; }
        
        /* ==================== INTERFACE DE JEU ==================== */
        #game-container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* ==================== HEADER ==================== */
        #game-header {
            height: 70px;
            background: linear-gradient(90deg, var(--panel-bg), rgba(20, 20, 45, 0.98));
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 25px;
            border-bottom: 1px solid var(--glass-border);
            box-shadow: 0 5px 30px rgba(0,0,0,0.5);
            position: relative;
            z-index: 100;
            isolation: isolate;
        }
        
        #game-header * {
            position: relative;
            transform: none;
            animation: none;
        }
        
        #game-header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary), var(--secondary), var(--primary), transparent);
            opacity: 0.5;
            pointer-events: none;
        }
        
        .team-badge {
            padding: 10px 25px;
            border-radius: 25px;
            font-weight: 700;
            text-transform: uppercase;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            letter-spacing: 2px;
        }
        
        .team-red { background: linear-gradient(135deg, #ff4757, #c0392b); box-shadow: 0 0 20px rgba(255, 71, 87, 0.4); }
        .team-blue { background: linear-gradient(135deg, #3498db, #2980b9); box-shadow: 0 0 20px rgba(52, 152, 219, 0.4); }
        .team-green { background: linear-gradient(135deg, #2ecc71, #27ae60); box-shadow: 0 0 20px rgba(46, 204, 113, 0.4); }
        .team-yellow { background: linear-gradient(135deg, #f1c40f, #f39c12); box-shadow: 0 0 20px rgba(241, 196, 15, 0.4); color: #1a1a1a; }
        
        .resources-panel {
            display: flex;
            gap: 25px;
            font-size: 16px;
        }
        
        .resource {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 15px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
        }
        
        .resource:hover {
            background: rgba(0, 242, 254, 0.1);
            border-color: var(--primary);
        }
        
        .resource-icon { 
            font-size: 24px;
            line-height: 1;
            animation: none !important;
            transform: none !important;
            filter: none !important;
            position: static !important;
        }
        
        .resource-value { 
            font-weight: 700; 
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            color: var(--primary);
        }
        
        /* ==================== MAIN AREA ==================== */
        #main-area {
            flex: 1;
            display: flex;
            position: relative;
        }
        
        /* ==================== LEFT PANEL ==================== */
        #left-panel {
            width: 300px;
            background: var(--panel-bg);
            border-right: 1px solid var(--glass-border);
            padding: 20px;
            overflow-y: auto;
            animation: slideInLeft 0.5s ease-out;
            backdrop-filter: blur(10px);
        }
        
        #left-panel::-webkit-scrollbar {
            width: 6px;
        }
        
        #left-panel::-webkit-scrollbar-track {
            background: transparent;
        }
        
        #left-panel::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 3px;
        }
        
        .panel-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 13px;
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .panel-title::before {
            content: '';
            width: 4px;
            height: 20px;
            background: linear-gradient(180deg, var(--primary), var(--secondary));
            border-radius: 2px;
        }
        
        /* Base placement message */
        #base-message {
            background: linear-gradient(135deg, rgba(243, 156, 18, 0.2), rgba(231, 76, 60, 0.2));
            border: 1px solid var(--warning);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }
        
        #base-message h3 {
            margin-bottom: 10px;
            color: var(--warning);
            font-family: 'Orbitron', sans-serif;
        }
        
        /* Unit buttons */
        .unit-btn {
            width: 100%;
            padding: 15px;
            margin-bottom: 12px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            color: white;
            cursor: pointer;
            text-align: left;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .unit-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 242, 254, 0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .unit-btn:hover:not(:disabled)::before {
            left: 100%;
        }
        
        .unit-btn:hover:not(:disabled) {
            background: rgba(0, 242, 254, 0.1);
            border-color: var(--primary);
            transform: translateX(5px);
            box-shadow: 0 5px 25px rgba(0, 242, 254, 0.2);
        }
        
        .unit-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(0.5);
        }
        
        .unit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .unit-name {
            font-size: 16px;
            font-weight: 600;
            font-family: 'Rajdhani', sans-serif;
        }
        
        .unit-icon { 
            font-size: 28px;
            display: inline-block;
            vertical-align: middle;
            flex-shrink: 0;
        }
        
        .unit-cost {
            font-size: 13px;
            color: var(--warning);
            font-weight: 600;
        }
        
        .unit-stats {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
            display: flex;
            gap: 15px;
        }
        
        .unit-stats span {
            padding: 2px 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
        }
        
        /* Production queue */
        #production-queue {
            margin-top: 25px;
        }
        
        .queue-item {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            padding: 12px;
            border-radius: 10px;
            margin-bottom: 10px;
            animation: fadeInUp 0.3s ease-out;
        }
        
        .queue-progress {
            height: 6px;
            background: rgba(0,0,0,0.4);
            border-radius: 3px;
            margin-top: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .queue-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            transition: width 0.3s ease;
            border-radius: 3px;
            position: relative;
        }
        
        .queue-progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            animation: shimmer 1.5s infinite;
        }
        
        /* ==================== MAP CONTAINER ==================== */
        #map-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: radial-gradient(ellipse at center, #1a2a3a 0%, #0a0a1a 100%);
        }
        
        #map-svg {
            position: absolute;
            top: 0;
            left: 0;
            cursor: grab;
            background: transparent;
        }
        
        #map-svg:active { cursor: grabbing; }
        
        .territory {
            stroke: rgba(0, 0, 0, 0.6);
            stroke-width: 6;
            stroke-linejoin: round;
            transition: fill 0.3s ease, stroke 0.3s ease;
            cursor: pointer;
        }
        
        .territory:hover {
            filter: brightness(1.3);
            stroke-width: 8;
        }
        
        .territory.neutral { fill: #3a4a5a; }
        .territory.team-red { fill: #c0392b; }
        .territory.team-blue { fill: #2980b9; }
        .territory.team-green { fill: #27ae60; }
        .territory.team-yellow { fill: #d68910; }
        
        .territory.selected {
            stroke: #fff;
            stroke-width: 10;
            filter: brightness(1.2);
        }
        
        .territory.my-base {
            stroke: var(--warning);
            stroke-width: 8;
        }
        
        .territory.my-base.selected {
            stroke: #fff;
            stroke-width: 12;
        }
        
        @keyframes myBasePulse {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.4); }
        }
        
        .territory.can-move {
            stroke: var(--success);
            stroke-width: 8;
            stroke-dasharray: 15 8;
            animation: dash 0.8s linear infinite;
        }
        
        @keyframes dash {
            to { stroke-dashoffset: -23; }
        }
        
        /* Unit markers on map */
        .unit-marker {
            pointer-events: none;
            font-size: 16px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .base-marker {
            pointer-events: none;
            font-size: 24px;
            text-shadow: 0 0 8px currentColor;
        }
        
        /* ==================== RIGHT PANEL ==================== */
        #right-panel {
            width: 320px;
            background: var(--panel-bg);
            border-left: 1px solid var(--glass-border);
            display: flex;
            flex-direction: column;
            max-height: 100vh;
            overflow: hidden;
            animation: slideInRight 0.5s ease-out;
            backdrop-filter: blur(10px);
        }
        
        #right-panel-content {
            flex: 1;
            overflow-y: auto;
            min-height: 0;
            padding: 15px;
        }
        
        #right-panel-content::-webkit-scrollbar {
            width: 6px;
        }
        
        #right-panel-content::-webkit-scrollbar-track {
            background: transparent;
        }
        
        #right-panel-content::-webkit-scrollbar-thumb {
            background: var(--secondary);
            border-radius: 3px;
        }
        
        /* Territory info */
        #territory-info {
            padding: 15px;
            background: var(--glass);
            border-radius: 12px;
            margin-bottom: 15px;
            border: 1px solid var(--glass-border);
        }
        
        #territory-name {
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 8px;
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        #territory-details {
            font-size: 13px;
            color: #8892b0;
            line-height: 1.6;
        }
        
        /* Units in territory */
        #units-list {
            padding: 10px 0;
        }
        
        .unit-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--glass);
            border-radius: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            border: 1px solid var(--glass-border);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .unit-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 3px;
            height: 100%;
            background: linear-gradient(180deg, var(--primary), var(--secondary));
            transform: scaleY(0);
            transition: transform 0.3s ease;
        }
        
        .unit-item:hover {
            background: rgba(79, 172, 254, 0.1);
            border-color: var(--secondary);
            transform: translateX(5px);
        }
        
        .unit-item:hover::before {
            transform: scaleY(1);
        }
        
        .unit-item.selected {
            border-color: var(--primary);
            background: rgba(0, 242, 254, 0.15);
            box-shadow: 0 0 20px rgba(0, 242, 254, 0.2);
        }
        
        .unit-item.selected::before {
            transform: scaleY(1);
        }
        
        .unit-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: var(--primary);
            cursor: pointer;
        }
        
        /* Action buttons */
        #action-buttons {
            padding: 15px;
            border-top: 1px solid var(--glass-border);
            background: rgba(10, 10, 26, 0.5);
        }
        
        .action-btn {
            width: 100%;
            padding: 14px 20px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 15px;
            font-weight: 700;
            font-family: 'Rajdhani', sans-serif;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .action-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s ease;
        }
        
        .action-btn:hover:not(:disabled)::before {
            left: 100%;
        }
        
        .action-btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0, 242, 254, 0.3);
        }
        
        .action-btn:active:not(:disabled) {
            transform: translateY(-1px);
        }
        
        .action-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(0.5);
        }
        
        .action-btn.attack {
            background: linear-gradient(135deg, var(--danger), #a31621);
        }
        
        .action-btn.attack:hover:not(:disabled) {
            box-shadow: 0 10px 30px rgba(231, 76, 60, 0.4);
        }
        
        /* ==================== TEAMS PANEL ==================== */
        #teams-panel {
            padding: 12px 15px;
            border-top: 1px solid var(--glass-border);
            background: rgba(10, 10, 26, 0.8);
            flex-shrink: 0;
            backdrop-filter: blur(10px);
        }
        
        #teams-panel .panel-title {
            font-size: 11px;
            margin-bottom: 8px;
            color: #666;
        }
        
        .team-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin-bottom: 4px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            font-family: 'Rajdhani', sans-serif;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        .team-stat::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 3px;
            background: currentColor;
            opacity: 0.8;
        }
        
        .team-stat:hover {
            transform: translateX(5px);
        }
        
        /* ==================== MINIMAP ==================== */
        #minimap-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 220px;
            background: var(--panel-bg);
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            animation: slideInLeft 0.6s ease-out;
        }
        
        #goto-base-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, var(--warning), #ff8c00);
            border: none;
            color: #1a1a2e;
            font-weight: 700;
            font-size: 13px;
            font-family: 'Rajdhani', sans-serif;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        #goto-base-btn:hover {
            background: linear-gradient(135deg, #ffed4a, #ffa500);
            transform: scale(1.02);
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.4);
        }
        
        #minimap {
            width: 100%;
            height: 160px;
            background: #0a0a1a;
        }
        
        #minimap-viewport {
            position: absolute;
            border: 2px solid var(--primary);
            pointer-events: none;
            box-shadow: 0 0 10px var(--primary);
        }
        
        /* ==================== CHAT ==================== */
        #chat-container {
            position: absolute;
            bottom: 20px;
            right: 340px;
            width: 320px;
            height: 220px;
            background: var(--panel-bg);
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            animation: fadeInUp 0.5s ease-out;
        }
        
        #chat-messages {
            flex: 1;
            padding: 12px;
            overflow-y: auto;
            font-size: 13px;
        }
        
        #chat-messages::-webkit-scrollbar {
            width: 4px;
        }
        
        #chat-messages::-webkit-scrollbar-thumb {
            background: var(--glass-border);
            border-radius: 2px;
        }
        
        .chat-msg {
            margin-bottom: 8px;
            padding: 6px 10px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.2);
            animation: fadeInUp 0.2s ease-out;
        }
        
        .chat-msg .author {
            font-weight: 700;
            font-family: 'Rajdhani', sans-serif;
        }
        
        #chat-input-container {
            display: flex;
            padding: 12px;
            border-top: 1px solid var(--glass-border);
            gap: 10px;
            background: rgba(0, 0, 0, 0.2);
        }
        
        #chat-input {
            flex: 1;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            color: white;
            outline: none;
            font-family: 'Rajdhani', sans-serif;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        #chat-input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 15px rgba(0, 242, 254, 0.2);
        }
        
        #chat-input::placeholder {
            color: #666;
        }
        
        #chat-send {
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border: none;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            font-weight: 700;
            font-family: 'Rajdhani', sans-serif;
            text-transform: uppercase;
            transition: all 0.3s ease;
        }
        
        #chat-send:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0, 242, 254, 0.3);
        }
        
        /* ==================== NOTIFICATIONS ==================== */
        #notifications {
            position: absolute;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .notification {
            background: var(--panel-bg);
            padding: 15px 30px;
            border-radius: 12px;
            border: 1px solid var(--glass-border);
            border-left: 4px solid var(--primary);
            animation: notificationSlide 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(15px);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            font-family: 'Rajdhani', sans-serif;
            font-size: 15px;
            font-weight: 500;
            max-width: 400px;
            text-align: center;
        }
        
        .notification.error {
            border-left-color: var(--danger);
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.1), var(--panel-bg));
        }
        
        .notification.battle {
            border-left-color: var(--warning);
            background: linear-gradient(135deg, rgba(243, 156, 18, 0.1), var(--panel-bg));
        }
        
        .notification.success {
            border-left-color: var(--success);
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.1), var(--panel-bg));
        }
        
        @keyframes notificationSlide {
            0% {
                opacity: 0;
                transform: translateY(-30px) scale(0.9);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        /* Territoire dans le chemin */
        .territory.in-path {
            stroke: var(--accent);
            stroke-width: 10;
            filter: brightness(1.4) drop-shadow(0 0 15px var(--accent));
        }
        
        /* Territoire waypoint (Shift+clic) */
        .territory.waypoint {
            stroke: #e67e22;
            stroke-width: 10;
            stroke-dasharray: 15 8;
            animation: waypointPulse 1s ease-in-out infinite;
        }
        
        @keyframes waypointPulse {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.4) drop-shadow(0 0 15px rgba(230, 126, 34, 0.6)); }
        }
        
        .waypoint-marker {
            pointer-events: none;
            text-shadow: 2px 2px 3px rgba(0,0,0,0.8);
        }
        
        /* ==================== CONTROL GROUP INDICATOR ==================== */
        .control-group-indicator {
            position: absolute;
            top: -10px;
            right: -10px;
            background: linear-gradient(135deg, var(--accent), #9b59b6);
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            font-size: 11px;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 10px rgba(155, 89, 182, 0.5);
            animation: pulse 2s infinite;
        }
        
        /* ==================== SOUND TOGGLE ==================== */
        #sound-toggle {
            background: linear-gradient(135deg, var(--success), #16a085);
            border: none;
            padding: 10px 18px;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            font-size: 16px;
            font-weight: 700;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-left: 15px;
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.3);
        }
        
        #sound-toggle:hover {
            transform: scale(1.1) rotate(5deg);
            box-shadow: 0 6px 25px rgba(46, 204, 113, 0.5);
        }
        
        #sound-toggle.muted {
            background: linear-gradient(135deg, #7f8c8d, #95a5a6);
            box-shadow: none;
        }
        
        /* ==================== MOVING UNITS PANEL ==================== */
        #moving-units-panel {
            padding: 15px;
            border-top: 1px solid var(--glass-border);
            max-height: 180px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
        }
        
        #moving-units-panel::-webkit-scrollbar {
            width: 5px;
        }
        
        #moving-units-panel::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 3px;
        }
        
        .moving-item {
            background: var(--glass);
            padding: 12px;
            border-radius: 10px;
            margin-bottom: 10px;
            border-left: 3px solid var(--accent);
            transition: all 0.3s ease;
            animation: fadeInUp 0.3s ease-out;
        }
        
        .moving-item:hover {
            background: rgba(155, 89, 182, 0.1);
            transform: translateX(5px);
        }
        
        .moving-progress {
            height: 5px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 3px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        .moving-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #9b59b6);
            transition: width 0.5s ease;
            border-radius: 3px;
            position: relative;
        }
        
        .moving-progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 1.5s infinite;
        }
        
        /* ==================== BATTLE MODAL ==================== */
        #battle-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(10px);
        }
        
        .battle-container {
            background: linear-gradient(135deg, rgba(26, 26, 62, 0.98), rgba(42, 42, 78, 0.98));
            border: 2px solid var(--warning);
            border-radius: 25px;
            padding: 35px;
            min-width: 850px;
            max-width: 950px;
            box-shadow: 
                0 0 60px rgba(243, 156, 18, 0.3),
                0 25px 80px rgba(0, 0, 0, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            animation: battleModalAppear 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        @keyframes battleModalAppear {
            0% {
                opacity: 0;
                transform: scale(0.8) translateY(50px);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }
        
        .battle-header {
            text-align: center;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--glass-border);
        }
        
        .battle-header h2 {
            font-size: 32px;
            font-family: 'Orbitron', sans-serif;
            color: var(--warning);
            margin-bottom: 8px;
            text-shadow: 0 0 20px rgba(243, 156, 18, 0.5);
            animation: glow 2s ease-in-out infinite;
        }
        
        .battle-header .territory-name {
            color: #8892b0;
            font-size: 16px;
            font-family: 'Rajdhani', sans-serif;
        }
        
        .battle-armies {
            display: flex;
            gap: 35px;
            margin-bottom: 25px;
        }
        
        .army-side {
            flex: 1;
            padding: 25px;
            border-radius: 18px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }
        
        .army-side.attacker {
            border: 2px solid var(--danger);
            box-shadow: 0 10px 40px rgba(231, 76, 60, 0.2);
        }
        
        .army-side.defender {
            border: 2px solid var(--secondary);
            box-shadow: 0 10px 40px rgba(52, 152, 219, 0.2);
        }
        
        .army-title {
            font-size: 22px;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
            margin-bottom: 18px;
            display: flex;
            align-items: center;
            gap: 12px;
            letter-spacing: 1px;
        }
        
        .army-side.attacker .army-title {
            color: var(--danger);
        }
        
        .army-side.defender .army-title {
            color: var(--secondary);
        }
        
        .army-units {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 320px;
            overflow-y: auto;
            padding-right: 10px;
        }
        
        .army-units::-webkit-scrollbar {
            width: 5px;
        }
        
        .army-units::-webkit-scrollbar-thumb {
            background: var(--glass-border);
            border-radius: 3px;
        }
        
        .battle-unit {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 14px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            border: 1px solid transparent;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .battle-unit:hover {
            background: rgba(255, 255, 255, 0.08);
        }
        
        .battle-unit.attacking {
            background: rgba(243, 156, 18, 0.25);
            transform: scale(1.03);
            box-shadow: 0 0 30px rgba(243, 156, 18, 0.4);
            border-color: var(--warning);
        }
        
        .battle-unit.hit {
            animation: hitFlash 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .battle-unit.dead {
            opacity: 0.25;
            filter: grayscale(1);
            transform: scale(0.95);
        }
        
        @keyframes hitFlash {
            0% { 
                background: rgba(255, 0, 0, 0.6); 
                transform: translateX(-8px) scale(1.02); 
            }
            50% { 
                background: rgba(255, 0, 0, 0.9); 
                transform: translateX(8px) scale(1.02); 
            }
            100% { 
                background: rgba(255, 255, 255, 0.03); 
                transform: translateX(0) scale(1); 
            }
        }
        
        .unit-icon-large {
            font-size: 36px;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            display: inline-block;
            flex-shrink: 0;
        }
        
        .unit-info {
            flex: 1;
        }
        
        .unit-type-name {
            font-weight: 700;
            font-size: 15px;
            font-family: 'Rajdhani', sans-serif;
            letter-spacing: 0.5px;
        }
        
        .unit-stats-battle {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }
        
        .health-bar-wrapper {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .health-bar-container {
            width: 150px;
            height: 24px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid var(--glass-border);
            position: relative;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.5);
        }
        
        .health-bar {
            height: 100%;
            background: linear-gradient(180deg, #3ae374, #27ae60);
            transition: width 0.5s ease-out;
            border-radius: 10px;
            position: relative;
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.5);
        }
        
        .health-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255,255,255,0.3), transparent);
            border-radius: 10px 10px 0 0;
        }
        
        .health-bar.low {
            background: linear-gradient(180deg, #f9ca24, #e67e22);
            box-shadow: 0 0 10px rgba(230, 126, 34, 0.5);
        }
        
        .health-bar.critical {
            background: linear-gradient(180deg, #ff6b6b, #c0392b);
            animation: criticalPulse 0.5s ease-in-out infinite;
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.6);
        }
        
        @keyframes criticalPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: 700;
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,1), -1px -1px 3px rgba(0,0,0,1);
            white-space: nowrap;
            z-index: 1;
            font-family: 'Rajdhani', sans-serif;
        }
        
        .health-value-outside {
            font-size: 17px;
            font-weight: 700;
            color: var(--primary);
            min-width: 75px;
            text-align: right;
            font-family: 'Orbitron', sans-serif;
        }
        
        .health-value-outside.low {
            color: var(--warning);
        }
        
        .health-value-outside.critical {
            color: var(--danger);
            animation: criticalPulse 0.5s ease-in-out infinite;
        }
        
        .battle-log {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            padding: 18px;
            margin-bottom: 20px;
            max-height: 140px;
            overflow-y: auto;
            border: 1px solid var(--glass-border);
        }
        
        .battle-log::-webkit-scrollbar {
            width: 5px;
        }
        
        .battle-log::-webkit-scrollbar-thumb {
            background: var(--warning);
            border-radius: 3px;
        }
        
        .battle-log-title {
            font-size: 13px;
            color: #666;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-family: 'Orbitron', sans-serif;
        }
        
        .battle-log-entry {
            font-size: 13px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            font-family: 'Rajdhani', sans-serif;
            animation: fadeInUp 0.2s ease-out;
        }
        
        .battle-log-entry:last-child {
            border-bottom: none;
        }
        
        .battle-log-entry .damage {
            color: var(--danger);
            font-weight: 700;
        }
        
        .battle-log-entry .attacker-name {
            color: var(--warning);
        }
        
        .battle-log-entry .defender-name {
            color: var(--secondary);
        }
        
        .battle-result {
            text-align: center;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 20px;
            animation: resultAppear 0.5s ease-out;
        }
        
        @keyframes resultAppear {
            0% {
                opacity: 0;
                transform: scale(0.8);
            }
            50% {
                transform: scale(1.05);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .battle-result.victory {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.3), rgba(46, 204, 113, 0.2));
            border: 2px solid var(--success);
            box-shadow: 0 10px 40px rgba(46, 204, 113, 0.3);
        }
        
        .battle-result.defeat {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.3), rgba(192, 57, 43, 0.2));
            border: 2px solid var(--danger);
            box-shadow: 0 10px 40px rgba(231, 76, 60, 0.3);
        }
        
        .battle-result h3 {
            font-size: 28px;
            margin-bottom: 12px;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 3px;
        }
        
        .battle-result.victory h3 {
            color: var(--success);
            text-shadow: 0 0 20px rgba(46, 204, 113, 0.5);
        }
        
        .battle-result.defeat h3 {
            color: var(--danger);
            text-shadow: 0 0 20px rgba(231, 76, 60, 0.5);
        }
        
        .battle-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        
        .battle-btn {
            padding: 14px 35px;
            font-size: 15px;
            font-weight: 700;
            font-family: 'Rajdhani', sans-serif;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .battle-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s ease;
        }
        
        .battle-btn:hover::before {
            left: 100%;
        }
        
        .battle-btn.primary {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            box-shadow: 0 5px 25px rgba(0, 242, 254, 0.3);
        }
        
        .battle-btn.secondary {
            background: var(--glass);
            color: white;
            border: 2px solid var(--glass-border);
        }
        
        .battle-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(0, 242, 254, 0.4);
        }
        
        .battle-btn.secondary:hover {
            border-color: var(--primary);
            box-shadow: 0 8px 30px rgba(0, 242, 254, 0.2);
        }
        
        /* ==================== MOVING MARKERS ==================== */
        .moving-marker {
            pointer-events: none;
            transition: all 0.5s ease-out;
        }
        
        @keyframes marchPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }
        
        .moving-marker-icon {
            animation: marchPulse 1s infinite;
            text-shadow: 0 0 6px currentColor;
        }
        
        /* ==================== ARTILLERY RANGE ==================== */
        .territory.in-range {
            stroke: var(--danger);
            stroke-width: 8;
            stroke-dasharray: 15 8;
            animation: rangeGlow 1.5s ease-in-out infinite;
        }
        
        @keyframes rangeGlow {
            0%, 100% { filter: brightness(1) drop-shadow(0 0 5px rgba(231, 76, 60, 0.3)); }
            50% { filter: brightness(1.4) drop-shadow(0 0 20px rgba(231, 76, 60, 0.7)); }
        }
        
        /* ==================== FOG OF WAR ==================== */
        .territory.fog {
            fill: #0d0d1a !important;
            filter: blur(3px);
            opacity: 0.4;
            transition: all 0.5s ease;
        }
        
        .territory.fog:hover {
            filter: blur(2px) brightness(1.2);
            opacity: 0.5;
        }
        
        /* ==================== FLAG ANIMATIONS ==================== */
        .flag-marker {
            pointer-events: none;
            transform-origin: bottom left;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        @keyframes flagWave {
            0% { transform: rotate(-3deg) skewX(0deg); }
            25% { transform: rotate(2deg) skewX(5deg); }
            50% { transform: rotate(-2deg) skewX(-3deg); }
            75% { transform: rotate(3deg) skewX(4deg); }
            100% { transform: rotate(-3deg) skewX(0deg); }
        }
        
        @keyframes flagClothWave {
            0%, 100% { 
                transform: scaleX(1) skewY(0deg);
            }
            25% { 
                transform: scaleX(0.95) skewY(3deg);
            }
            50% { 
                transform: scaleX(1.05) skewY(-2deg);
            }
            75% { 
                transform: scaleX(0.97) skewY(2deg);
            }
        }
        
        .flag-pole {
            stroke: #8B4513;
            stroke-width: 3;
        }
        
        .flag-cloth {
            animation: flagCloth 1.5s ease-in-out infinite;
        }
        
        @keyframes flagCloth {
            0%, 100% { d: path('M0,0 Q15,-5 30,0 Q15,5 0,0'); }
            50% { d: path('M0,0 Q15,5 30,0 Q15,-5 0,0'); }
        }
        
        /* ==================== WEATHER INDICATOR ==================== */
        #weather-indicator {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            padding: 10px 25px;
            border-radius: 25px;
            border: 1px solid var(--glass-border);
            font-size: 16px;
            z-index: 50;
            backdrop-filter: blur(10px);
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.4);
            animation: fadeInUp 0.5s ease-out;
        }
        
        /* ==================== WAR/PEACE INDICATOR ==================== */
        #war-peace-indicator {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            padding: 12px 30px;
            border-radius: 20px;
            font-size: 18px;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
            z-index: 50;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
        }
        
        #war-peace-indicator.war {
            border: 2px solid var(--danger);
            box-shadow: 0 0 30px rgba(231, 76, 60, 0.4);
            animation: warPulse 2s ease-in-out infinite;
        }
        
        #war-peace-indicator.peace {
            border: 2px solid var(--success);
            box-shadow: 0 0 30px rgba(39, 174, 96, 0.4);
            animation: peacePulse 3s ease-in-out infinite;
        }
        
        @keyframes warPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(231, 76, 60, 0.4); }
            50% { box-shadow: 0 0 50px rgba(231, 76, 60, 0.8); }
        }
        
        @keyframes peacePulse {
            0%, 100% { box-shadow: 0 0 20px rgba(39, 174, 96, 0.4); }
            50% { box-shadow: 0 0 40px rgba(39, 174, 96, 0.7); }
        }
        
        #war-peace-indicator .state-name {
            font-size: 24px;
            letter-spacing: 2px;
        }
        
        #war-peace-indicator .state-timer {
            font-size: 14px;
            color: #8892b0;
            font-family: 'Rajdhani', sans-serif;
        }
        
        #war-peace-indicator .state-bonus {
            font-size: 13px;
            color: var(--primary);
            margin-top: 3px;
            font-family: 'Rajdhani', sans-serif;
        }
        
        /* ==================== WEATHER EFFECTS ==================== */
        #map-container.rainy::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(transparent 0%, rgba(74, 144, 226, 0.15) 100%);
            pointer-events: none;
            z-index: 10;
        }
        
        #map-container.stormy::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.35);
            pointer-events: none;
            z-index: 10;
            animation: stormFlash 3s infinite;
        }
        
        @keyframes stormFlash {
            0%, 95%, 100% { opacity: 1; }
            96% { opacity: 0.2; background: rgba(255, 255, 255, 0.1); }
            97% { opacity: 1; }
        }
        
        #map-container.night::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 50, 0.45);
            pointer-events: none;
            z-index: 10;
        }
        
        /* ==================== EXPLOSION ANIMATION ==================== */
        .explosion-marker {
            pointer-events: none;
            animation: explode 0.6s ease-out forwards;
        }
        
        @keyframes explode {
            0% { transform: scale(0.3); opacity: 1; filter: brightness(2); }
            30% { transform: scale(1.5); opacity: 1; }
            100% { transform: scale(3); opacity: 0; filter: brightness(0.5); }
        }
        
        /* ==================== DIRECTION ARROW ==================== */
        .direction-arrow {
            pointer-events: none;
            fill: var(--accent);
            opacity: 0.85;
        }
        
        /* ==================== TECH PANEL ==================== */
        #tech-panel {
            padding: 15px;
            border-top: 1px solid var(--glass-border);
            max-height: 220px;
            overflow-y: auto;
        }
        
        #tech-panel::-webkit-scrollbar {
            width: 5px;
        }
        
        #tech-panel::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 3px;
        }
        
        .tech-btn {
            width: 100%;
            padding: 12px 15px;
            margin-bottom: 10px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            color: white;
            cursor: pointer;
            text-align: left;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .tech-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(155, 89, 182, 0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .tech-btn:hover:not(:disabled)::before {
            left: 100%;
        }
        
        .tech-btn:hover:not(:disabled) {
            background: rgba(155, 89, 182, 0.1);
            border-color: var(--accent);
            transform: translateX(5px);
        }
        
        .tech-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(0.5);
        }
        
        .tech-btn.researched {
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.2), rgba(39, 174, 96, 0.1));
            border-color: var(--success);
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.2);
        }
        
        /* ==================== RESOURCE BONUS MARKERS ==================== */
        .bonus-marker {
            pointer-events: none;
            opacity: 0.9;
        }
        
        /* ==================== TERRAIN MARKERS ==================== */
        .terrain-marker {
            pointer-events: none;
            text-shadow: 2px 2px 3px rgba(0,0,0,0.6);
            opacity: 0.95;
        }
        
        /* ==================== HELP BUTTON ==================== */
        #help-btn {
            background: linear-gradient(135deg, var(--accent), #8e44ad);
            border: none;
            padding: 10px 18px;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            font-size: 16px;
            font-weight: 700;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(155, 89, 182, 0.3);
        }
        
        #help-btn:hover {
            transform: scale(1.1) rotate(-5deg);
            box-shadow: 0 6px 25px rgba(155, 89, 182, 0.5);
        }
        
        /* ==================== HELP MODAL ==================== */
        #help-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            backdrop-filter: blur(10px);
        }
        
        .help-container {
            background: linear-gradient(135deg, rgba(26, 26, 62, 0.98), rgba(42, 42, 78, 0.98));
            border: 2px solid var(--accent);
            border-radius: 25px;
            padding: 35px;
            max-width: 950px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 
                0 0 60px rgba(155, 89, 182, 0.3),
                0 25px 80px rgba(0, 0, 0, 0.5);
            animation: battleModalAppear 0.5s ease-out;
        }
        
        .help-container::-webkit-scrollbar {
            width: 6px;
        }
        
        .help-container::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 3px;
        }
        
        .help-header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--glass-border);
        }
        
        .help-header h2 {
            font-size: 32px;
            color: var(--accent);
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 2px;
        }
        
        .help-section {
            margin-bottom: 30px;
        }
        
        .help-section h3 {
            color: var(--primary);
            font-size: 20px;
            font-family: 'Orbitron', sans-serif;
            margin-bottom: 18px;
            border-left: 4px solid var(--primary);
            padding-left: 15px;
        }
        
        .help-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 18px;
        }
        
        .help-item {
            background: var(--glass);
            padding: 18px;
            border-radius: 12px;
            border: 1px solid var(--glass-border);
            transition: all 0.3s ease;
        }
        
        .help-item:hover {
            transform: translateY(-3px);
            border-color: var(--primary);
            box-shadow: 0 10px 30px rgba(0, 242, 254, 0.1);
        }
        
        .help-item-title {
            font-size: 18px;
            font-weight: 700;
            font-family: 'Rajdhani', sans-serif;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .help-item-desc {
            font-size: 13px;
            color: #8892b0;
            line-height: 1.6;
        }
        
        .help-item-stats {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--glass-border);
        }
        
        .help-close-btn {
            display: block;
            margin: 25px auto 0;
            padding: 14px 50px;
            background: linear-gradient(135deg, var(--accent), #8e44ad);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 16px;
            font-weight: 700;
            font-family: 'Rajdhani', sans-serif;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .help-close-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(155, 89, 182, 0.4);
        }
        
        .shortcut-key {
            background: rgba(0, 0, 0, 0.4);
            padding: 4px 10px;
            border-radius: 6px;
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            margin-left: 6px;
            border: 1px solid var(--glass-border);
        }
        
        /* ==================== LEADERBOARD ==================== */
        #leaderboard {
            position: absolute;
            top: 75px;
            right: 340px;
            background: var(--panel-bg);
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            padding: 18px;
            min-width: 240px;
            z-index: 50;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
        }
        
        #leaderboard.collapsed {
            transform: translateX(calc(100% + 15px));
            opacity: 0;
            pointer-events: none;
        }
        
        #leaderboard-toggle {
            background: linear-gradient(135deg, var(--warning), #e67e22);
            border: none;
            padding: 10px 18px;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            font-size: 16px;
            font-weight: 700;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-right: 12px;
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.3);
        }
        
        #leaderboard-toggle:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 25px rgba(243, 156, 18, 0.5);
        }
        
        #leaderboard-toggle.active {
            background: linear-gradient(135deg, var(--success), #16a085);
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.3);
        }
        
        .leaderboard-title {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 12px;
            text-align: center;
            font-family: 'Orbitron', sans-serif;
        }
        
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            margin-bottom: 5px;
            border-radius: 8px;
            font-size: 13px;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .leaderboard-item:hover {
            background: rgba(255, 255, 255, 0.05);
            transform: translateX(3px);
        }
        
        .leaderboard-item.me {
            background: rgba(0, 242, 254, 0.1);
            border: 1px solid var(--primary);
            box-shadow: 0 0 15px rgba(0, 242, 254, 0.2);
        }
        
        .leaderboard-rank {
            color: var(--warning);
            font-weight: 700;
            margin-right: 10px;
            font-family: 'Orbitron', sans-serif;
        }
        
        /* ==================== PLAYER STATS ==================== */
        #stats-btn {
            background: linear-gradient(135deg, var(--secondary), #2980b9);
            border: none;
            padding: 10px 18px;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            font-size: 16px;
            font-weight: 700;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-left: 12px;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }
        
        #stats-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 25px rgba(52, 152, 219, 0.5);
        }
        
        #stats-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            backdrop-filter: blur(10px);
        }
        
        .stats-container {
            background: linear-gradient(135deg, rgba(26, 26, 62, 0.98), rgba(42, 42, 78, 0.98));
            border: 2px solid var(--secondary);
            border-radius: 25px;
            padding: 35px;
            min-width: 450px;
            box-shadow: 
                0 0 60px rgba(52, 152, 219, 0.3),
                0 25px 80px rgba(0, 0, 0, 0.5);
            animation: battleModalAppear 0.5s ease-out;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 14px 18px;
            background: var(--glass);
            border-radius: 10px;
            margin-bottom: 10px;
            border: 1px solid var(--glass-border);
            transition: all 0.3s ease;
        }
        
        .stat-row:hover {
            background: rgba(79, 172, 254, 0.1);
            transform: translateX(5px);
        }
        
        .stat-label {
            color: #8892b0;
            font-family: 'Rajdhani', sans-serif;
        }
        
        .stat-value {
            font-weight: 700;
            color: var(--primary);
            font-family: 'Orbitron', sans-serif;
        }
        
        /* ==================== PLAYERS BUTTON & MODAL ==================== */
        #players-btn {
            background: linear-gradient(135deg, var(--accent), #8e44ad);
            border: none;
            padding: 10px 18px;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            font-size: 16px;
            font-weight: 700;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-right: 12px;
            box-shadow: 0 4px 15px rgba(155, 89, 182, 0.3);
        }
        
        #players-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 25px rgba(155, 89, 182, 0.5);
        }
        
        #players-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            backdrop-filter: blur(10px);
        }
        
        .players-container {
            background: linear-gradient(135deg, rgba(26, 26, 62, 0.98), rgba(42, 42, 78, 0.98));
            border: 2px solid var(--accent);
            border-radius: 25px;
            padding: 35px;
            min-width: 850px;
            max-width: 1050px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 
                0 0 60px rgba(155, 89, 182, 0.3),
                0 25px 80px rgba(0, 0, 0, 0.5);
            animation: battleModalAppear 0.5s ease-out;
        }
        
        .players-container::-webkit-scrollbar {
            width: 6px;
        }
        
        .players-container::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 3px;
        }
        
        .players-header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--glass-border);
        }
        
        .players-header h2 {
            font-size: 32px;
            color: var(--accent);
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 2px;
        }
        
        .players-header p {
            color: #8892b0;
            margin-top: 8px;
            font-family: 'Rajdhani', sans-serif;
        }
        
        .teams-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
        }
        
        .team-card {
            background: var(--glass);
            border-radius: 18px;
            padding: 22px;
            border: 2px solid;
            transition: all 0.3s ease;
        }
        
        .team-card:hover {
            transform: translateY(-5px);
        }
        
        .team-card.red { border-color: var(--danger); box-shadow: 0 10px 40px rgba(231, 76, 60, 0.2); }
        .team-card.blue { border-color: var(--secondary); box-shadow: 0 10px 40px rgba(52, 152, 219, 0.2); }
        .team-card.green { border-color: var(--success); box-shadow: 0 10px 40px rgba(39, 174, 96, 0.2); }
        .team-card.yellow { border-color: var(--warning); box-shadow: 0 10px 40px rgba(243, 156, 18, 0.2); }
        
        .team-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 18px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--glass-border);
        }
        
        .team-card-header h3 {
            font-size: 20px;
            font-family: 'Orbitron', sans-serif;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .team-card.red .team-card-header h3 { color: var(--danger); }
        .team-card.blue .team-card-header h3 { color: var(--secondary); }
        .team-card.green .team-card-header h3 { color: var(--success); }
        .team-card.yellow .team-card-header h3 { color: var(--warning); }
        
        .team-stats {
            font-size: 13px;
            color: #8892b0;
            font-family: 'Rajdhani', sans-serif;
        }
        
        .player-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }
        
        .player-row:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateX(5px);
        }
        
        .player-row.me {
            background: rgba(0, 242, 254, 0.15);
            border: 1px solid var(--primary);
            box-shadow: 0 0 15px rgba(0, 242, 254, 0.2);
        }
        
        .player-row.has-base {
            border-left: 4px solid var(--warning);
        }
        
        .player-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .player-name {
            font-weight: 700;
            font-size: 14px;
            font-family: 'Rajdhani', sans-serif;
        }
        
        .player-status {
            font-size: 11px;
            padding: 3px 10px;
            border-radius: 12px;
            background: rgba(39, 174, 96, 0.25);
            color: var(--success);
            font-weight: 600;
        }
        
        .player-status.no-base {
            background: rgba(231, 76, 60, 0.25);
            color: var(--danger);
        }
        
        .player-stats {
            display: flex;
            gap: 18px;
            font-size: 12px;
            color: #8892b0;
        }
        
        .player-stat {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .no-players {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 25px;
        }
        
        .players-close-btn {
            display: block;
            margin: 30px auto 0;
            padding: 14px 50px;
            background: linear-gradient(135deg, var(--accent), #8e44ad);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 16px;
            font-weight: 700;
            font-family: 'Rajdhani', sans-serif;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .players-close-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(155, 89, 182, 0.4);
        }
        
        .online-count {
            background: linear-gradient(135deg, var(--success), #16a085);
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 12px;
            color: white;
            font-weight: 600;
        }
        
        /* ==================== SCROLLBAR GLOBAL ==================== */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--primary), var(--secondary));
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, var(--secondary), var(--primary));
        }
        
        /* ==================== TOOLTIPS ==================== */
        [data-tooltip] {
            position: relative;
        }
        
        [data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            border: 1px solid var(--glass-border);
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            animation: fadeInUp 0.2s ease-out;
        }
        
        /* ==================== SELECTION HIGHLIGHT ==================== */
        ::selection {
            background: var(--primary);
            color: white;
        }
    </style>
</head>
<body>
    <!-- Modal de connexion -->
    <div id="login-modal" class="modal-overlay">
        <div class="modal-content">
            <h1>⚔️ WAR TERRITORY</h1>
            <h2>RTS Multijoueur Online</h2>
            
            <!-- Formulaire de connexion/inscription -->
            <div id="auth-tabs" style="display: flex; gap: 10px; margin-bottom: 20px; justify-content: center; flex-wrap: wrap;">
                <button class="auth-tab active" onclick="showAuthTab('login')" id="tab-login" style="padding: 10px 25px; background: #4ecdc4; border: none; border-radius: 8px; color: white; cursor: pointer; font-weight: bold;">Connexion</button>
                <button class="auth-tab" onclick="showAuthTab('register')" id="tab-register" style="padding: 10px 25px; background: #3a3a5e; border: 2px solid #4a4a8e; border-radius: 8px; color: white; cursor: pointer;">Inscription</button>
                <button class="auth-tab" onclick="showAuthTab('guest')" id="tab-guest" style="padding: 10px 25px; background: #3a3a5e; border: 2px solid #4a4a8e; border-radius: 8px; color: white; cursor: pointer;">Invité</button>
                <button class="auth-tab" onclick="showAuthTab('spectator')" id="tab-spectator" style="padding: 10px 25px; background: #3a3a5e; border: 2px solid #4a4a8e; border-radius: 8px; color: white; cursor: pointer;">👁️ Spectateur</button>
            </div>
            
            <!-- Formulaire Connexion -->
            <div id="form-login">
                <input type="text" id="login-username" placeholder="Nom d'utilisateur" maxlength="20" style="width: 300px; padding: 15px 20px; font-size: 18px; border: 2px solid #4a4a8e; border-radius: 10px; background: #1a1a3e; color: white; outline: none; margin-bottom: 10px;">
                <br>
                <input type="password" id="login-password" placeholder="Mot de passe" style="width: 300px; padding: 15px 20px; font-size: 18px; border: 2px solid #4a4a8e; border-radius: 10px; background: #1a1a3e; color: white; outline: none; margin-bottom: 10px;">
                <br>
                <label style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 15px; color: #888; font-size: 14px;">
                    <input type="checkbox" id="load-saved-data" checked style="width: 18px; height: 18px;">
                    Charger ma progression sauvegardée
                </label>
                <button id="login-btn" style="width: 300px; padding: 15px; font-size: 20px; background: linear-gradient(45deg, #4ecdc4, #45b7d1); border: none; border-radius: 10px; color: white; cursor: pointer; font-weight: bold;">🔓 SE CONNECTER</button>
            </div>
            
            <!-- Formulaire Inscription -->
            <div id="form-register" class="hidden">
                <input type="text" id="register-username" placeholder="Nom d'utilisateur (3-20 car.)" maxlength="20" style="width: 300px; padding: 15px 20px; font-size: 18px; border: 2px solid #4a4a8e; border-radius: 10px; background: #1a1a3e; color: white; outline: none; margin-bottom: 10px;">
                <br>
                <input type="email" id="register-email" placeholder="Email (optionnel)" style="width: 300px; padding: 15px 20px; font-size: 18px; border: 2px solid #4a4a8e; border-radius: 10px; background: #1a1a3e; color: white; outline: none; margin-bottom: 10px;">
                <br>
                <input type="password" id="register-password" placeholder="Mot de passe (min 4 car.)" style="width: 300px; padding: 15px 20px; font-size: 18px; border: 2px solid #4a4a8e; border-radius: 10px; background: #1a1a3e; color: white; outline: none; margin-bottom: 10px;">
                <br>
                <input type="password" id="register-confirm" placeholder="Confirmer mot de passe" style="width: 300px; padding: 15px 20px; font-size: 18px; border: 2px solid #4a4a8e; border-radius: 10px; background: #1a1a3e; color: white; outline: none; margin-bottom: 15px;">
                <br>
                <button id="register-btn" style="width: 300px; padding: 15px; font-size: 20px; background: linear-gradient(45deg, #27ae60, #2ecc71); border: none; border-radius: 10px; color: white; cursor: pointer; font-weight: bold;">📝 S'INSCRIRE</button>
            </div>
            
            <!-- Formulaire Invité -->
            <div id="form-guest" class="hidden">
                <input type="text" id="player-name" placeholder="Votre nom de commandant" maxlength="20" style="width: 300px; padding: 15px 20px; font-size: 18px; border: 2px solid #4a4a8e; border-radius: 10px; background: #1a1a3e; color: white; outline: none; margin-bottom: 15px;">
                <br>
                <button id="join-btn" style="width: 300px; padding: 15px; font-size: 20px; background: linear-gradient(45deg, #f39c12, #e67e22); border: none; border-radius: 10px; color: white; cursor: pointer; font-weight: bold;">🎮 JOUER EN INVITÉ</button>
                <p style="margin-top: 15px; color: #e74c3c; font-size: 13px;">
                    ⚠️ Vos données ne seront pas sauvegardées !
                </p>
            </div>
            
            <!-- Formulaire Spectateur -->
            <div id="form-spectator" class="hidden">
                <div style="font-size: 60px; margin-bottom: 20px;">👁️</div>
                <p style="color: #888; margin-bottom: 20px; font-size: 16px;">
                    Regardez la partie en cours sans pouvoir agir.<br>
                    Vous verrez toutes les équipes et leurs actions !
                </p>
                <input type="text" id="spectator-name" placeholder="Votre pseudo (optionnel)" maxlength="20" style="width: 300px; padding: 15px 20px; font-size: 18px; border: 2px solid #4a4a8e; border-radius: 10px; background: #1a1a3e; color: white; outline: none; margin-bottom: 15px;">
                <br>
                <button id="spectator-btn" style="width: 300px; padding: 15px; font-size: 20px; background: linear-gradient(45deg, #9b59b6, #8e44ad); border: none; border-radius: 10px; color: white; cursor: pointer; font-weight: bold;">👁️ OBSERVER LA PARTIE</button>
            </div>
            
            <div id="auth-error" style="color: #e74c3c; margin-top: 15px; display: none;"></div>
            <div id="auth-success" style="color: #27ae60; margin-top: 15px; display: none;"></div>
            
            <p style="margin-top: 20px; color: #666; font-size: 14px;">
                Créez un compte pour sauvegarder votre progression !
            </p>
        </div>
    </div>

    <!-- Interface de jeu -->
    <div id="game-container" class="hidden">
        <!-- Header -->
        <div id="game-header">
            <div style="display: flex; align-items: center; gap: 20px;">
                <span id="player-badge" class="team-badge">ÉQUIPE</span>
                <span id="player-display-name">Commandant</span>
                <span id="auth-indicator" style="font-size: 12px; color: #888;"></span>
            </div>
            <div class="resources-panel" style="display: flex; gap: 25px; position: relative; z-index: 1;">
                <div class="resource" style="display: flex; align-items: center; gap: 10px; padding: 8px 15px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px;">
                    <span style="font-size: 24px; display: inline-block;">💰</span>
                    <span class="resource-value" id="gold-value" style="font-weight: 700; font-family: Orbitron, sans-serif; font-size: 18px; color: #00f2fe;">0</span>
                    <span id="gold-income" style="font-size: 12px; color: #27ae60; margin-left: 5px;">(+0/min)</span>
                </div>
                <div class="resource" style="display: flex; align-items: center; gap: 10px; padding: 8px 15px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px;">
                    <span style="font-size: 24px; display: inline-block;">🍖</span>
                    <span class="resource-value" id="food-value" style="font-weight: 700; font-family: Orbitron, sans-serif; font-size: 18px; color: #00f2fe;">0</span>
                    <span id="food-income" style="font-size: 12px; color: #27ae60; margin-left: 5px;">(+0/min)</span>
                </div>
                <div class="resource" style="display: flex; align-items: center; gap: 10px; padding: 8px 15px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px;">
                    <span style="font-size: 24px; display: inline-block;">🎖️</span>
                    <span class="resource-value" id="unit-count" style="font-weight: 700; font-family: Orbitron, sans-serif; font-size: 18px; color: #00f2fe;">0/20</span>
                </div>
            </div>
            <div id="game-title" style="font-size: 20px; font-weight: bold;">
                ⚔️ WAR TERRITORY
            </div>
            <div>
                <button id="leaderboard-toggle" onclick="toggleLeaderboard()">🏆 Classement</button>
                <button id="players-btn" onclick="togglePlayersModal()">👥 Joueurs</button>
                <button id="help-btn">❓ Aide</button>
                <button id="stats-btn">📊 Stats</button>
                <button id="sound-toggle" onclick="toggleSound()">🔊 Son</button>
                <button id="logout-btn" onclick="logout()" style="background: linear-gradient(45deg, #e74c3c, #c0392b); border: none; padding: 8px 15px; border-radius: 20px; color: white; cursor: pointer; font-size: 14px; margin-left: 10px; display: none;">🚪 Déconnexion</button>
            </div>
        </div>

        <!-- Main area -->
        <div id="main-area">
            <!-- Left Panel - Production -->
            <div id="left-panel">
                <div id="base-message">
                    <h3>🏰 Placez votre base</h3>
                    <p>Cliquez sur le territoire de votre équipe (coloré) pour placer votre QG</p>
                </div>
                
                <!-- Message quand base placée mais rien sélectionné -->
                <div id="select-base-message" class="hidden">
                    <div style="padding: 20px; text-align: center; color: #888;">
                        <p>🏰 Cliquez sur votre <strong>base</strong> ou un <strong>bâtiment</strong> pour produire des unités</p>
                        <p style="margin-top: 10px;">👷 Utilisez un <strong>Constructeur</strong> pour bâtir de nouveaux bâtiments</p>
                    </div>
                </div>
                
                <div id="production-panel" class="hidden">
                    <div class="panel-title" id="production-title">⚔️ Produire des unités</div>
                    <div id="production-source-info" style="color: #4ecdc4; font-size: 12px; margin-bottom: 10px;"></div>
                    <div id="unit-buttons"></div>
                    
                    <div id="production-queue">
                        <div class="panel-title">📋 File de production</div>
                        <div id="queue-items"></div>
                    </div>
                </div>
                
                <!-- Panel de construction (quand un Builder est sélectionné) -->
                <div id="build-panel" class="hidden">
                    <div class="panel-title">🏗️ Construire un bâtiment</div>
                    <div id="builder-info" style="color: #f39c12; font-size: 12px; margin-bottom: 10px;"></div>
                    <div id="building-buttons"></div>
                </div>
            </div>

            <!-- Map -->
            <div id="map-container">
                <svg id="map-svg"></svg>
                <div id="weather-indicator">☀️ Ensoleillé</div>
                
                <!-- Indicateur Guerre/Paix -->
                <div id="war-peace-indicator" class="war">
                    <span class="state-name">⚔️ GUERRE</span>
                    <span class="state-timer">Prochain changement: --:--:--</span>
                    <span class="state-bonus">Attaques autorisées</span>
                </div>
                
                <!-- Leaderboard -->
                <div id="leaderboard" class="collapsed">
                    <div class="leaderboard-title">🏆 Meilleurs Joueurs</div>
                    <div id="leaderboard-list"></div>
                </div>
                
                <div id="minimap-container">
                    <button id="goto-base-btn" onclick="centerOnMyBase()" title="Centrer sur ma base">🏰 Ma Base</button>
                    <canvas id="minimap"></canvas>
                    <div id="minimap-viewport"></div>
                </div>
                <div id="notifications"></div>
            </div>

            <!-- Right Panel -->
            <div id="right-panel">
                <!-- Conteneur scrollable pour le contenu principal -->
                <div id="right-panel-content">
                    <div id="territory-info">
                        <div id="territory-name">Sélectionnez un territoire</div>
                        <div id="territory-details"></div>
                    </div>
                    
                    <div id="units-list">
                        <div class="panel-title">🎖️ Unités sur ce territoire</div>
                        <div id="units-container"></div>
                    </div>
                    
                    <div id="action-buttons">
                        <button class="action-btn" id="move-btn" disabled>
                            ➡️ Déplacer (1 case)
                        </button>
                        <button class="action-btn" id="path-btn" disabled style="background: linear-gradient(45deg, #9b59b6, #8e44ad);">
                            🗺️ Tracer chemin (multi-cases)
                        </button>
                        <button class="action-btn attack" id="attack-btn" disabled>
                            ⚔️ Attaquer
                        </button>
                    </div>
                    
                    <!-- Troupes en mouvement -->
                    <div id="moving-units-panel" class="hidden">
                        <div class="panel-title">🚶 Troupes en mouvement</div>
                        <div id="moving-units-list"></div>
                    </div>
                    
                    <!-- Panneau Technologies -->
                    <div id="tech-panel">
                        <div class="panel-title">🔬 Technologies</div>
                        <div id="tech-buttons"></div>
                    </div>
                </div>
                
                <!-- Scores toujours visibles en bas -->
                <div id="teams-panel">
                    <div class="panel-title">🏆 Scores des équipes</div>
                    <div class="team-stat team-red">
                        <span>🔴 Rouge</span>
                        <span id="team-red-score">0 territoires (0 joueurs)</span>
                    </div>
                    <div class="team-stat team-blue">
                        <span>🔵 Bleu</span>
                        <span id="team-blue-score">0 territoires (0 joueurs)</span>
                    </div>
                    <div class="team-stat team-green">
                        <span>🟢 Vert</span>
                        <span id="team-green-score">0 territoires (0 joueurs)</span>
                    </div>
                    <div class="team-stat team-yellow">
                        <span>🟡 Jaune</span>
                        <span id="team-yellow-score">0 territoires (0 joueurs)</span>
                    </div>
                </div>
            </div>

            <!-- Chat -->
            <div id="chat-container">
                <div id="chat-messages"></div>
                <div id="chat-input-container">
                    <input type="text" id="chat-input" placeholder="Message..." maxlength="200">
                    <button id="chat-send">📨</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal d'Aide -->
    <div id="help-modal" class="hidden">
        <div class="help-container">
            <div class="help-header">
                <h2>📖 Guide du Commandant</h2>
                <p style="color: #888;">Tout ce que vous devez savoir pour conquérir le monde !</p>
            </div>
            
            <div class="help-section">
                <h3>🏗️ Bâtiments</h3>
                <div class="help-grid">
                    <div class="help-item">
                        <div class="help-item-title">🏰 Base (QG)</div>
                        <div class="help-item-desc">Votre quartier général. Produit des unités de base (infanterie, constructeur). Si elle est détruite, vous perdez !</div>
                        <div class="help-item-stats">❤️ 1000 HP | Produit: Infanterie, Constructeur</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">🏠 Caserne</div>
                        <div class="help-item-desc">Produit des unités d'infanterie et de support. Essentielle pour former votre armée !</div>
                        <div class="help-item-stats">💰 1000 | ⏱️ 1 min | Produit: Infanterie, Builder, Scout, Médic</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">🏭 Usine</div>
                        <div class="help-item-desc">Produit des unités avancées comme les tanks et l'artillerie. Essentielle pour les batailles !</div>
                        <div class="help-item-stats">💰 1500 | ⏱️ 1m30 | Produit: Tank, Véhicule Léger, Artillerie</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">🛫 Héliport</div>
                        <div class="help-item-desc">Produit des hélicoptères, unités aériennes puissantes et rapides.</div>
                        <div class="help-item-stats">💰 2000 | ⏱️ 2 min | Produit: Hélicoptère</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">🗼 Tour de défense</div>
                        <div class="help-item-desc">Structure défensive qui attaque automatiquement les ennemis.</div>
                        <div class="help-item-stats">💰 800 | ⏱️ 45s | ⚔️ 20 | 🛡️ 30 | ❤️ 300</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">🌾 Ferme</div>
                        <div class="help-item-desc">Produit automatiquement de la nourriture chaque tour. La nourriture est nécessaire pour déplacer vos troupes !</div>
                        <div class="help-item-stats">💰 500 | ⏱️ 40s | Production: +8 🍖/tick</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">⛏️ Mine d'or</div>
                        <div class="help-item-desc">Produit automatiquement de l'or chaque tour. L'or sert à produire des unités et construire.</div>
                        <div class="help-item-stats">💰 700 | ⏱️ 50s | Production: +15 💰/tick</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">🏨 Hôpital</div>
                        <div class="help-item-desc">Soigne automatiquement les unités blessées sur le territoire chaque tour.</div>
                        <div class="help-item-stats">💰 900 | ⏱️ 55s | Soin: +10 ❤️/tick par unité</div>
                    </div>
                </div>
            </div>
            
            <div class="help-section">
                <h3>⚔️ Unités de Combat</h3>
                <div class="help-grid">
                    <div class="help-item">
                        <div class="help-item-title">🚶 Infanterie</div>
                        <div class="help-item-desc">Unité de base, polyvalente et peu coûteuse. Bonne pour conquérir des territoires.</div>
                        <div class="help-item-stats">💰 80 + 30🍖 | ⚔️ 10 | 🛡️ 8 | ❤️ 100 | ⏱️ 2min/case | 🔨 30s</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">🚗 Tank</div>
                        <div class="help-item-desc">Unité blindée puissante mais lente. Excellent en attaque et défense.</div>
                        <div class="help-item-stats">💰 250 + 80🍖 | ⚔️ 30 | 🛡️ 25 | ❤️ 300 | ⏱️ 3min/case | 🔨 1m30</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">🚙 Véhicule Léger</div>
                        <div class="help-item-desc">Véhicule rapide avec bonne défense. Idéal pour les raids et la défense mobile.</div>
                        <div class="help-item-stats">💰 180 + 60🍖 | ⚔️ 20 | 🛡️ 35 | ❤️ 180 | ⏱️ 1m30/case | 🔨 1min</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">💥 Artillerie</div>
                        <div class="help-item-desc">Peut attaquer à distance (2 cases) ! Puissante à distance mais très faible au corps à corps. Rechargement: 1 minute.</div>
                        <div class="help-item-stats">💰 350 + 60🍖 | ⚔️ 5 (corps) / 50 (tir) | 🛡️ 5 | ❤️ 150 | ⏱️ 4min/case | 📏 2 | 🔨 40s</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">🚁 Hélicoptère</div>
                        <div class="help-item-desc">Unité aérienne très rapide et puissante. Idéale pour les frappes éclair.</div>
                        <div class="help-item-stats">💰 500 + 80🍖 | ⚔️ 40 | 🛡️ 15 | ❤️ 200 | ⏱️ 1min/case | 🔨 1m30</div>
                    </div>
                </div>
            </div>
            
            <div class="help-section">
                <h3>🔧 Unités de Support</h3>
                <div class="help-grid">
                    <div class="help-item">
                        <div class="help-item-title">👷 Constructeur</div>
                        <div class="help-item-desc">Construit des bâtiments sur vos territoires. Faible en combat.</div>
                        <div class="help-item-stats">💰 150 + 50🍖 | ⚔️ 2 | 🛡️ 5 | ❤️ 80 | ⏱️ 2m30/case | 🔨 1min</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">🏃 Éclaireur</div>
                        <div class="help-item-desc">Le plus rapide ! Révèle le brouillard de guerre sur 3 cases. Ne combat pas.</div>
                        <div class="help-item-stats">💰 60 + 25🍖 | ⚔️ 0 | 🛡️ 3 | ❤️ 50 | ⏱️ 30s/case | 👁️ Vision: 3 | 🔨 20s</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">🏥 Médecin</div>
                        <div class="help-item-desc">Soigne vos unités pendant les combats. Essentiel pour les longues batailles !</div>
                        <div class="help-item-stats">💰 120 + 40🍖 | ⚔️ 0 | 🛡️ 5 | ❤️ 70 | ⏱️ 2min/case | 💊 Soin: 15/tour | 🔨 40s</div>
                    </div>
                </div>
            </div>
            
            <div class="help-section">
                <h3>📊 Légende des Statistiques</h3>
                <div style="background: rgba(78, 205, 196, 0.2); padding: 15px; border-radius: 10px; border: 1px solid #4ecdc4;">
                    <p>💰 <strong>Coût Or</strong> + 🍖 <strong>Coût Nourriture</strong></p>
                    <p>⚔️ <strong>Attaque</strong> - Dégâts infligés en attaque</p>
                    <p>🛡️ <strong>Défense</strong> - Dégâts infligés en défense</p>
                    <p>❤️ <strong>Points de vie</strong></p>
                    <p>⏱️ <strong>Temps de voyage</strong> - Secondes par case (base: 3s, modifié par vitesse)</p>
                    <p>🔨 <strong>Temps de production</strong></p>
                    <p>📏 <strong>Portée</strong> - Distance d'attaque à distance</p>
                    <p>👁️ <strong>Vision</strong> - Cases de brouillard révélées</p>
                    <p style="margin-top: 10px; color: #f39c12;">⚠️ Coût déplacement: 8🍖 par unité par case traversée</p>
                </div>
            </div>
            
            <div class="help-section">
                <h3>🎮 Contrôles</h3>
                <div class="help-grid">
                    <div class="help-item">
                        <div class="help-item-title">🖱️ Clic Gauche</div>
                        <div class="help-item-desc">Sélectionner territoire/unités. En mode chemin: ajouter un point.</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">🖱️ Clic Droit</div>
                        <div class="help-item-desc">Confirmer le déplacement sur le chemin tracé.</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">ESC <span class="shortcut-key">Échap</span></div>
                        <div class="help-item-desc">Annuler le chemin en cours ou désélectionner.</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">🖱️ Molette</div>
                        <div class="help-item-desc">Zoomer/dézoomer sur la carte.</div>
                    </div>
                    <div class="help-item" style="border-color: #e67e22;">
                        <div class="help-item-title">⇧ Shift + Clic</div>
                        <div class="help-item-desc">Ajouter des waypoints pour créer une file d'attente de déplacements. Clic droit pour confirmer.</div>
                    </div>
                    <div class="help-item" style="border-color: #9b59b6;">
                        <div class="help-item-title">Ctrl + 1-9 <span class="shortcut-key">Ctrl+1</span></div>
                        <div class="help-item-desc">Sauvegarder les unités sélectionnées dans un groupe de contrôle.</div>
                    </div>
                    <div class="help-item" style="border-color: #9b59b6;">
                        <div class="help-item-title">1-9 <span class="shortcut-key">1</span></div>
                        <div class="help-item-desc">Rappeler un groupe de contrôle sauvegardé et centrer la carte sur lui.</div>
                    </div>
                    <div class="help-item" style="border-color: #3498db;">
                        <div class="help-item-title">Ctrl + A <span class="shortcut-key">Ctrl+A</span></div>
                        <div class="help-item-desc">Sélectionner toutes vos unités sur le territoire actuel.</div>
                    </div>
                    <div class="help-item" style="border-color: #1abc9c;">
                        <div class="help-item-title">M <span class="shortcut-key">M</span></div>
                        <div class="help-item-desc">Activer/désactiver les sons d'alerte.</div>
                    </div>
                    <div class="help-item" style="border-color: #27ae60;">
                        <div class="help-item-title">🗺️ Minimap</div>
                        <div class="help-item-desc">Cliquez ou faites glisser sur la minimap pour naviguer rapidement sur la carte.</div>
                    </div>
                </div>
            </div>
            
            <div class="help-section">
                <h3>🌦️ Système Météo</h3>
                <div class="help-grid">
                    <div class="help-item">
                        <div class="help-item-title">☀️ Ensoleillé</div>
                        <div class="help-item-desc">Conditions idéales. Aucun malus.</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">🌧️ Pluvieux</div>
                        <div class="help-item-desc">Vitesse de déplacement réduite de 20%.</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">⛈️ Orageux</div>
                        <div class="help-item-desc">Vitesse réduite de 40%, vision réduite de 1 case.</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">🌙 Nuit</div>
                        <div class="help-item-desc">Vision réduite de 2 cases. Idéal pour les attaques surprises !</div>
                    </div>
                </div>
            </div>
            
            <div class="help-section">
                <h3>�️ Types de Terrain</h3>
                <div class="help-grid">
                    <div class="help-item">
                        <div class="help-item-title">🌾 Plaine</div>
                        <div class="help-item-desc">Terrain standard sans bonus ni malus. Parfait pour les déplacements rapides.</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">⛰️ Montagne</div>
                        <div class="help-item-desc">Défense +50%, mais attaque -20% et vitesse -40%. Idéal pour défendre !</div>
                        <div class="help-item-stats">+5 💰 Or/tour</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">🌲 Forêt</div>
                        <div class="help-item-desc">Défense +20%, vitesse -20%. 25% de chance d'embuscade qui réduit les dégâts ennemis au premier tour !</div>
                        <div class="help-item-stats">+5 🍖 Nourriture/tour</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">🌊 Rivière</div>
                        <div class="help-item-desc">Défense +30%, attaque ennemie -30%, vitesse -50%. Très difficile à traverser !</div>
                        <div class="help-item-stats">+3 🍖 Nourriture/tour (pêche)</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">🏜️ Désert</div>
                        <div class="help-item-desc">Attaque et défense -10%, vitesse -30%. Conditions difficiles mais riche en ressources.</div>
                        <div class="help-item-stats">+8 💰 Or/tour</div>
                    </div>
                    <div class="help-item">
                        <div class="help-item-title">🐊 Marécage</div>
                        <div class="help-item-desc">Très lent (-60% vitesse), 15% de chance d'embuscade. Évitez si possible !</div>
                    </div>
                </div>
            </div>
            
            <div class="help-section">
                <h3>⚠️ Capture de Territoire</h3>
                <div style="background: rgba(231, 76, 60, 0.2); padding: 15px; border-radius: 10px; border: 1px solid #e74c3c;">
                    <p>💥 <strong>Quand un ennemi capture votre territoire</strong>, tous vos bâtiments dessus sont <strong style="color: #e74c3c;">DÉTRUITS</strong> !</p>
                    <p style="margin-top: 10px;">🛡️ <strong>Protégez vos fermes et mines</strong> avec des troupes pour éviter de perdre votre production.</p>
                    <p style="margin-top: 10px;">⛰️ <strong>Construisez sur des terrains défensifs</strong> (montagne, rivière) pour résister plus facilement.</p>
                </div>
            </div>
            
            <div class="help-section">
                <h3>⚔️🕊️ Système Guerre / Paix</h3>
                <div style="background: linear-gradient(135deg, rgba(231, 76, 60, 0.2), rgba(46, 204, 113, 0.2)); padding: 15px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.3);">
                    <p style="margin-bottom: 10px;">Le jeu alterne entre <strong>périodes de Guerre</strong> et <strong>périodes de Paix</strong> toutes les <strong>5 heures</strong>.</p>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px;">
                        <div style="background: rgba(231, 76, 60, 0.3); padding: 10px; border-radius: 8px; border-left: 3px solid #e74c3c;">
                            <p style="font-weight: bold; color: #e74c3c;">⚔️ GUERRE</p>
                            <p>• Attaquez <strong>tous les territoires</strong> (ennemis et neutres)</p>
                            <p>• Vitesse de déplacement normale</p>
                            <p>• Combat total !</p>
                        </div>
                        <div style="background: rgba(46, 204, 113, 0.3); padding: 10px; border-radius: 8px; border-left: 3px solid #2ecc71;">
                            <p style="font-weight: bold; color: #2ecc71;">🕊️ PAIX</p>
                            <p>• Attaquez <strong>uniquement les neutres</strong></p>
                            <p>• Vitesse de déplacement <strong>x5</strong> !</p>
                            <p>• Idéal pour expansion et économie</p>
                        </div>
                    </div>
                    
                    <p style="margin-top: 10px; font-style: italic; opacity: 0.8;">💡 Le compteur en haut de l'écran indique le temps restant avant le prochain changement.</p>
                </div>
            </div>
            
            <div class="help-section">
                <h3>💡 Conseils Stratégiques</h3>
                <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px; line-height: 1.8;">
                    <p>🌾 <strong>Construisez des fermes tôt</strong> - Le déplacement coûte 5 🍖 par unité par case !</p>
                    <p>⛏️ <strong>Les mines sont essentielles</strong> - Plus d'or = plus d'unités = victoire !</p>
                    <p>🏥 <strong>Placez des hôpitaux en première ligne</strong> - Vos troupes se soigneront automatiquement.</p>
                    <p>👁️ <strong>Utilisez les éclaireurs</strong> - Le brouillard cache les mouvements ennemis !</p>
                    <p>💥 <strong>L'artillerie change tout</strong> - Attaquez à distance sans risque !</p>
                    <p>🔬 <strong>Recherchez des technologies</strong> - Chaque amélioration vous donne un avantage !</p>
                    <p>⛰️ <strong>Utilisez le terrain</strong> - Une montagne peut transformer une défaite en victoire !</p>
                    <p>🕊️ <strong>Profitez de la Paix</strong> - Expandez rapidement avec la vitesse x5 !</p>
                    <p>⚔️ <strong>Préparez la Guerre</strong> - Positionnez vos troupes avant que les combats ne reprennent !</p>
                </div>
            </div>
            
            <button class="help-close-btn" onclick="document.getElementById('help-modal').classList.add('hidden')">✓ J'ai compris !</button>
        </div>
    </div>
    
    <!-- Modal Stats -->
    <div id="stats-modal" class="hidden">
        <div class="stats-container">
            <div class="help-header">
                <h2>📊 Vos Statistiques</h2>
            </div>
            <div id="stats-content">
                <div class="stat-row"><span class="stat-label">⚔️ Batailles gagnées</span><span class="stat-value" id="stat-wins">0</span></div>
                <div class="stat-row"><span class="stat-label">💀 Batailles perdues</span><span class="stat-value" id="stat-losses">0</span></div>
                <div class="stat-row"><span class="stat-label">🎯 Unités tuées</span><span class="stat-value" id="stat-kills">0</span></div>
                <div class="stat-row"><span class="stat-label">💔 Unités perdues</span><span class="stat-value" id="stat-deaths">0</span></div>
                <div class="stat-row"><span class="stat-label">🏴 Territoires conquis</span><span class="stat-value" id="stat-territories">0</span></div>
                <div class="stat-row"><span class="stat-label">🏗️ Bâtiments construits</span><span class="stat-value" id="stat-buildings">0</span></div>
                <div class="stat-row"><span class="stat-label">💰 Or total gagné</span><span class="stat-value" id="stat-gold">0</span></div>
            </div>
            <button class="help-close-btn" style="background: linear-gradient(45deg, #3498db, #2980b9);" onclick="document.getElementById('stats-modal').classList.add('hidden')">✓ Fermer</button>
        </div>
    </div>
    
    <!-- Modal Joueurs Connectés -->
    <div id="players-modal" class="hidden">
        <div class="players-container">
            <div class="players-header">
                <h2>👥 Joueurs Connectés</h2>
                <p>Tous les commandants actuellement en ligne</p>
            </div>
            
            <div class="teams-grid">
                <!-- Équipe Rouge -->
                <div class="team-card red">
                    <div class="team-card-header">
                        <h3>🔴 Équipe Rouge</h3>
                        <span class="team-stats" id="red-team-stats">0 joueurs | 0 territoires</span>
                    </div>
                    <div id="red-players-list"></div>
                </div>
                
                <!-- Équipe Bleue -->
                <div class="team-card blue">
                    <div class="team-card-header">
                        <h3>🔵 Équipe Bleue</h3>
                        <span class="team-stats" id="blue-team-stats">0 joueurs | 0 territoires</span>
                    </div>
                    <div id="blue-players-list"></div>
                </div>
                
                <!-- Équipe Verte -->
                <div class="team-card green">
                    <div class="team-card-header">
                        <h3>🟢 Équipe Verte</h3>
                        <span class="team-stats" id="green-team-stats">0 joueurs | 0 territoires</span>
                    </div>
                    <div id="green-players-list"></div>
                </div>
                
                <!-- Équipe Jaune -->
                <div class="team-card yellow">
                    <div class="team-card-header">
                        <h3>🟡 Équipe Jaune</h3>
                        <span class="team-stats" id="yellow-team-stats">0 joueurs | 0 territoires</span>
                    </div>
                    <div id="yellow-players-list"></div>
                </div>
            </div>
            
            <button class="players-close-btn" onclick="togglePlayersModal()">✓ Fermer</button>
        </div>
    </div>

    <!-- Modal de Combat -->
    <div id="battle-modal" class="hidden">
        <div class="battle-container">
            <div class="battle-header">
                <h2>⚔️ COMBAT</h2>
                <div class="territory-name" id="battle-territory-name">Territoire</div>
            </div>
            
            <div class="battle-armies">
                <div class="army-side attacker">
                    <div class="army-title">🗡️ ATTAQUANTS</div>
                    <div class="army-units" id="attacker-units"></div>
                </div>
                <div class="army-side defender">
                    <div class="army-title">🛡️ DÉFENSEURS</div>
                    <div class="army-units" id="defender-units"></div>
                </div>
            </div>
            
            <div class="battle-log">
                <div class="battle-log-title">📜 Journal de combat</div>
                <div id="battle-log-entries"></div>
            </div>
            
            <div class="battle-result hidden" id="battle-result">
                <h3 id="battle-result-title">Résultat</h3>
                <p id="battle-result-text"></p>
            </div>
            
            <div class="battle-buttons">
                <button class="battle-btn secondary" id="battle-skip-btn">⏩ Passer</button>
                <button class="battle-btn primary hidden" id="battle-close-btn">✓ Fermer</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== CONFIGURATION ====================
        const MAP_WIDTH = 10000;
        const MAP_HEIGHT = 7000;
        
        // ==================== ÉTAT DU JEU ====================
        let socket;
        let gameData = {
            player: null,
            territories: [],
            teams: {},
            config: null
        };
        
        let mapState = {
            scale: 0.12,
            offsetX: 0,
            offsetY: 0,
            isDragging: false,
            lastX: 0,
            lastY: 0
        };
        
        let selectedTerritory = null;
        let selectedUnits = new Set();
        let moveMode = false;
        let pathMode = false; // Mode sélection de chemin
        let currentPath = []; // Chemin en cours de construction
        let productionQueue = [];
        let movingUnits = []; // Unités en déplacement
        let artilleryMode = false; // Mode attaque artillerie longue portée
        let currentBattle = null; // Combat en cours
        let battleAnimationRunning = false; // Animation de combat en cours
        let artilleryReloadTimes = {}; // Temps de rechargement par unité d'artillerie
        let currentWeather = 'sunny'; // Météo actuelle
        let playerTechnologies = {}; // Technologies du joueur
        
        // ==================== SYSTÈME GUERRE/PAIX ====================
        let warPeaceState = {
            isWar: true,
            nextChange: Date.now() + 5 * 60 * 60 * 1000
        };
        
        // ==================== NOUVELLES FONCTIONNALITÉS QoL ====================
        let controlGroups = {}; // Groupes de contrôle (Ctrl+1 à 9)
        let waypointQueue = []; // File d'attente de waypoints (Shift+clic)
        let waypointMode = false; // Mode waypoint actif
        let soundEnabled = true; // Sons activés
        
        // Audio pour alertes
        const alertSounds = {
            attack: null,
            capture: null,
            production: null
        };
        
        // Initialiser les sons
        function initSounds() {
            // Créer des sons via Web Audio API
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                
                // Son d'alerte d'attaque (bip aigu)
                alertSounds.attack = () => {
                    if (!soundEnabled) return;
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.frequency.value = 800;
                    osc.type = 'square';
                    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                    osc.start(audioCtx.currentTime);
                    osc.stop(audioCtx.currentTime + 0.3);
                    // Deuxième bip
                    setTimeout(() => {
                        const osc2 = audioCtx.createOscillator();
                        const gain2 = audioCtx.createGain();
                        osc2.connect(gain2);
                        gain2.connect(audioCtx.destination);
                        osc2.frequency.value = 1000;
                        osc2.type = 'square';
                        gain2.gain.setValueAtTime(0.3, audioCtx.currentTime);
                        gain2.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                        osc2.start(audioCtx.currentTime);
                        osc2.stop(audioCtx.currentTime + 0.3);
                    }, 150);
                };
                
                // Son de capture de territoire
                alertSounds.capture = () => {
                    if (!soundEnabled) return;
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.frequency.value = 523; // Do
                    osc.type = 'sine';
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    osc.start(audioCtx.currentTime);
                    osc.stop(audioCtx.currentTime + 0.5);
                };
                
                // Son de production terminée
                alertSounds.production = () => {
                    if (!soundEnabled) return;
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.frequency.value = 440;
                    osc.type = 'triangle';
                    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    osc.start(audioCtx.currentTime);
                    osc.stop(audioCtx.currentTime + 0.2);
                };
            } catch (e) {
                console.log('Web Audio API non supportée');
            }
        }
        
        // ==================== AUTHENTIFICATION ====================
        let authToken = localStorage.getItem('warterritory_token');
        let currentUser = null;
        let isAuthenticated = false;
        let isSpectator = false;
        
        // Onglets d'authentification
        function showAuthTab(tab) {
            document.querySelectorAll('#auth-tabs button').forEach(btn => {
                btn.style.background = '#3a3a5e';
                btn.style.border = '2px solid #4a4a8e';
            });
            document.getElementById('form-login').classList.add('hidden');
            document.getElementById('form-register').classList.add('hidden');
            document.getElementById('form-guest').classList.add('hidden');
            document.getElementById('form-spectator').classList.add('hidden');
            document.getElementById('auth-error').style.display = 'none';
            document.getElementById('auth-success').style.display = 'none';
            
            const activeTab = document.getElementById('tab-' + tab);
            activeTab.style.background = tab === 'login' ? '#4ecdc4' : tab === 'register' ? '#27ae60' : tab === 'spectator' ? '#9b59b6' : '#f39c12';
            activeTab.style.border = 'none';
            
            document.getElementById('form-' + tab).classList.remove('hidden');
        }
        
        function showAuthError(message) {
            const el = document.getElementById('auth-error');
            el.textContent = message;
            el.style.display = 'block';
            document.getElementById('auth-success').style.display = 'none';
        }
        
        function showAuthSuccess(message) {
            const el = document.getElementById('auth-success');
            el.textContent = message;
            el.style.display = 'block';
            document.getElementById('auth-error').style.display = 'none';
        }
        
        // Inscription
        async function register() {
            const username = document.getElementById('register-username').value.trim();
            const email = document.getElementById('register-email').value.trim();
            const password = document.getElementById('register-password').value;
            const confirm = document.getElementById('register-confirm').value;
            
            if (!username || !password) {
                showAuthError('Nom d\'utilisateur et mot de passe requis');
                return;
            }
            
            if (password !== confirm) {
                showAuthError('Les mots de passe ne correspondent pas');
                return;
            }
            
            try {
                const res = await fetch('/api/register', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password, email: email || null })
                });
                
                const data = await res.json();
                
                if (data.success) {
                    authToken = data.token;
                    currentUser = data.user;
                    localStorage.setItem('warterritory_token', authToken);
                    showAuthSuccess('Compte créé ! Connexion en cours...');
                    setTimeout(() => connectToGame(username, authToken, false), 1000);
                } else {
                    showAuthError(data.error);
                }
            } catch (err) {
                showAuthError('Erreur de connexion au serveur');
            }
        }
        
        // Connexion
        async function login() {
            const username = document.getElementById('login-username').value.trim();
            const password = document.getElementById('login-password').value;
            const loadSaved = document.getElementById('load-saved-data').checked;
            
            if (!username || !password) {
                showAuthError('Nom d\'utilisateur et mot de passe requis');
                return;
            }
            
            try {
                const res = await fetch('/api/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password })
                });
                
                const data = await res.json();
                
                if (data.success) {
                    authToken = data.token;
                    currentUser = data.user;
                    localStorage.setItem('warterritory_token', authToken);
                    showAuthSuccess('Connexion réussie !');
                    setTimeout(() => connectToGame(username, authToken, loadSaved), 500);
                } else {
                    showAuthError(data.error);
                }
            } catch (err) {
                showAuthError('Erreur de connexion au serveur');
            }
        }
        
        // Déconnexion
        async function logout() {
            if (authToken) {
                try {
                    await fetch('/api/logout', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ token: authToken })
                    });
                } catch (err) {
                    console.error('Erreur déconnexion:', err);
                }
            }
            
            localStorage.removeItem('warterritory_token');
            authToken = null;
            currentUser = null;
            isAuthenticated = false;
            
            // Recharger la page
            location.reload();
        }
        
        // Vérifier session au chargement
        async function checkExistingSession() {
            if (!authToken) return false;
            
            try {
                const res = await fetch('/api/validate-session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token: authToken })
                });
                
                const data = await res.json();
                
                if (data.valid) {
                    currentUser = data.user;
                    document.getElementById('login-username').value = data.user.username;
                    showAuthSuccess(`Bienvenue ${data.user.username} ! Cliquez sur Connexion pour continuer.`);
                    return true;
                } else {
                    localStorage.removeItem('warterritory_token');
                    authToken = null;
                    return false;
                }
            } catch (err) {
                return false;
            }
        }
        
        // ==================== ÉLÉMENTS DOM ====================
        const loginModal = document.getElementById('login-modal');
        const gameContainer = document.getElementById('game-container');
        const playerNameInput = document.getElementById('player-name');
        const joinBtn = document.getElementById('join-btn');
        const spectatorBtn = document.getElementById('spectator-btn');
        const mapSvg = document.getElementById('map-svg');
        const mapContainer = document.getElementById('map-container');
        
        // ==================== CONNEXION ====================
        // Boutons d'authentification
        document.getElementById('login-btn').addEventListener('click', login);
        document.getElementById('register-btn').addEventListener('click', register);
        joinBtn.addEventListener('click', () => {
            const name = playerNameInput.value.trim() || 'Commandant';
            connectToGame(name, null, false);
        });
        
        // Bouton Spectateur
        spectatorBtn.addEventListener('click', () => {
            const name = document.getElementById('spectator-name').value.trim() || 'Spectateur';
            isSpectator = true;
            connectToGame(name, null, false, true);
        });
        
        // Entrée pour valider
        document.getElementById('login-password').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') login();
        });
        document.getElementById('register-confirm').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') register();
        });
        playerNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') joinBtn.click();
        });
        document.getElementById('spectator-name').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') spectatorBtn.click();
        });
        
        // Vérifier session existante au chargement
        checkExistingSession();
        
        function connectToGame(playerName, token = null, loadSavedData = false, spectatorMode = false) {
            socket = io();
            
            socket.on('connect', () => {
                console.log('Connecté au serveur');
                socket.emit('join_game', { 
                    playerName, 
                    token: token || authToken,
                    loadSavedData,
                    isSpectator: spectatorMode
                });
            });
            
            socket.on('game_joined', (data) => {
                console.log('Partie rejointe', data);
                console.log('Premiers territoires reçus:', data.territories.slice(0, 3).map(t => ({name: t.name, x: t.centerX, y: t.centerY})));
                gameData.player = data.player;
                gameData.territories = data.territories;
                gameData.teams = data.teams;
                gameData.config = data.config;
                
                // Mode spectateur
                if (data.player.isSpectator) {
                    isSpectator = true;
                    document.getElementById('auth-indicator').textContent = '👁️ Spectateur';
                    document.getElementById('logout-btn').style.display = 'none';
                    // Cacher les panneaux de production pour les spectateurs
                    document.getElementById('left-panel').innerHTML = '<div class="panel-title">👁️ MODE SPECTATEUR</div><p style="color:#888; padding:10px;">Vous observez la partie.<br>Vous ne pouvez pas interagir.</p>';
                    document.getElementById('base-message')?.remove();
                }
                // Vérifier si authentifié
                else if (data.player.isAuthenticated) {
                    isAuthenticated = true;
                    document.getElementById('auth-indicator').textContent = '🔐 Connecté';
                    document.getElementById('logout-btn').style.display = 'inline-block';
                } else {
                    document.getElementById('auth-indicator').textContent = '👤 Invité';
                    document.getElementById('logout-btn').style.display = 'none';
                }
                
                // Météo et technologies
                if (data.weather) {
                    currentWeather = data.weather.current;
                    updateWeatherDisplay(data.weather.current);
                }
                if (data.player.technologies) {
                    playerTechnologies = data.player.technologies;
                }
                
                // État Guerre/Paix
                if (data.warPeace) {
                    warPeaceState.isWar = data.warPeace.isWar;
                    warPeaceState.nextChange = data.warPeace.nextChange;
                    updateWarPeaceDisplay();
                }
                
                loginModal.classList.add('hidden');
                gameContainer.classList.remove('hidden');
                
                initGame();
            });
            
            socket.on('player_update', (data) => {
                Object.assign(gameData.player, data);
                updateUI();
            });
            
            socket.on('resources_update', (resources) => {
                gameData.player.resources = resources;
                updateResourcesDisplay();
            });
            
            socket.on('territory_update', (territory) => {
                const idx = gameData.territories.findIndex(t => t.id === territory.id);
                if (idx !== -1) {
                    const oldTerritory = gameData.territories[idx];
                    const wasOurs = oldTerritory.team === gameData.player?.team;
                    const isNowOurs = territory.team === gameData.player?.team;
                    
                    // Alerte si on perd un territoire
                    if (wasOurs && !isNowOurs && alertSounds.attack) {
                        alertSounds.attack();
                        showNotification(`⚠️ Territoire ${territory.name} PERDU!`, 'error');
                    }
                    // Son de capture si on gagne un territoire
                    if (!wasOurs && isNowOurs && alertSounds.capture) {
                        alertSounds.capture();
                    }
                    
                    Object.assign(gameData.territories[idx], territory);
                    updateTerritoryDisplay(territory.id);
                    
                    // Nettoyer les unités sélectionnées qui ne sont plus sur le territoire
                    if (selectedTerritory === territory.id && selectedUnits.size > 0) {
                        const currentUnitIds = new Set((territory.units || []).map(u => u.id));
                        const invalidUnits = [...selectedUnits].filter(id => !currentUnitIds.has(id));
                        invalidUnits.forEach(id => selectedUnits.delete(id));
                        
                        // Rafraîchir l'affichage si des unités ont été supprimées
                        if (invalidUnits.length > 0) {
                            updateUnitsList(gameData.territories[selectedTerritory]);
                            updateActionButtons();
                        }
                    }
                }
            });
            
            socket.on('teams_update', (teams) => {
                gameData.teams = teams;
                updateTeamsDisplay();
            });
            
            socket.on('base_placed', (data) => {
                showNotification(`🏰 ${data.playerName} a placé sa base!`);
            });
            
            socket.on('production_started', (data) => {
                productionQueue.push(data.item);
                gameData.player.resources = data.resources;
                updateResourcesDisplay();
                updateProductionQueue();
            });
            
            socket.on('unit_produced', (data) => {
                productionQueue = productionQueue.filter(p => p.id !== data.unit.id);
                showNotification(`✅ ${gameData.config.UNITS[data.unit.type].name} produit!`);
                if (alertSounds.production) alertSounds.production();
                updateProductionQueue();
            });
            
            socket.on('units_moved', (data) => {
                if (data.marching) {
                    // Les unités sont en marche
                    const seconds = Math.ceil(data.totalTime / 1000);
                    showNotification(`🚶 Troupes en marche! Arrivée dans ${seconds}s`);
                }
                selectedUnits.clear();
                moveMode = false;
                pathMode = false;
                artilleryMode = false;
                currentPath = [];
                updateHighlightedTerritories();
                updateUI();
            });
            
            // Combat animé
            // Fonction pour vérifier si c'est notre combat
            function isMyBattle(battleData) {
                if (isSpectator) return true;
                const myId = gameData.player?.oderId;
                // Vérifier si on est l'attaquant
                return battleData?.attackers?.some(u => u.ownerId === myId);
            }
            
            socket.on('battle_start', (data) => {
                console.log('Combat démarré:', data);
                console.log('Mon ID:', gameData.player?.oderId);
                console.log('Attackers ownerIds:', data.attackers?.map(u => u.ownerId));
                
                // Seul le joueur qui attaque voit l'animation
                if (!isMyBattle(data)) {
                    console.log('Pas mon combat - ignoré');
                    return;
                }
                
                startBattleAnimation(data);
            });
            
            socket.on('battle_result', (data) => {
                const territory = gameData.territories[data.territoryId];
                // La notification sera gérée par l'animation si elle est en cours
                if (!battleAnimationRunning) {
                    showNotification(`⚔️ Combat sur ${territory?.name || 'territoire'}!`, 'battle');
                }
            });
            
            // Changement Guerre/Paix
            socket.on('war_peace_change', (data) => {
                warPeaceState.isWar = data.isWar;
                warPeaceState.nextChange = data.nextChange;
                updateWarPeaceDisplay();
                
                // Son et notification spéciale
                if (data.isWar) {
                    showNotification('⚔️ PÉRIODE DE GUERRE! Les attaques sont maintenant autorisées!', 'battle');
                    if (alertSounds.attack) alertSounds.attack();
                } else {
                    showNotification('🕊️ PÉRIODE DE PAIX! Vitesse x5, attaques sur territoires neutres uniquement.', 'info');
                    if (alertSounds.capture) alertSounds.capture();
                }
            });
            
            // Artillerie - notification de tir et rechargement
            socket.on('artillery_fired', (data) => {
                const reloadSec = data.reloadTime / 1000;
                showNotification(`💥 Tir d'artillerie! Rechargement: ${reloadSec}s`, 'battle');
                
                // Stocker le temps de rechargement pour chaque unité
                data.unitIds.forEach(unitId => {
                    artilleryReloadTimes[unitId] = Date.now() + data.reloadTime;
                });
                
                // Mettre à jour l'affichage si nécessaire
                if (selectedTerritory !== null) {
                    updateUnitsList(gameData.territories[selectedTerritory]);
                }
            });
            
            // Unités en marche
            socket.on('units_marching', (data) => {
                movingUnits.push({
                    id: data.movementId,
                    units: data.units,
                    path: data.path,
                    startTime: data.startTime,
                    timePerTerritory: data.timePerTerritory,
                    totalTime: data.totalTime,
                    currentStep: 0
                });
                updateMovingUnitsDisplay();
                updateMovingMarkers();
            });
            
            socket.on('units_progress', (data) => {
                const movement = movingUnits.find(m => m.id === data.movementId);
                if (movement) {
                    movement.currentStep = data.currentStep;
                    
                    // Notifications de capture/combat en route
                    if (data.captured) {
                        const territory = gameData.territories[data.currentTerritoryId];
                        showNotification(`🏴 Territoire capturé en route: ${territory?.name || 'Territoire'}!`);
                    }
                    if (data.battle) {
                        const territory = gameData.territories[data.currentTerritoryId];
                        if (data.battleResult === 'victory') {
                            showNotification(`⚔️ Combat gagné sur ${territory?.name}! ${data.survivingUnits} survivants continuent.`, 'battle');
                        }
                    }
                    
                    updateMovingUnitsDisplay();
                    updateMovingMarkers();
                }
            });
            
            socket.on('units_arrived', (data) => {
                movingUnits = movingUnits.filter(m => m.id !== data.movementId);
                // Si combat, démarrer l'animation SEULEMENT si c'est notre combat
                if (data.battle && data.battleData && isMyBattle(data.battleData)) {
                    startBattleAnimation(data.battleData);
                } else if (data.battle) {
                    if (data.result?.allDead) {
                        showNotification(`💀 Toutes vos troupes ont été éliminées en route!`, 'error');
                    } else if (data.result?.attackerWins || data.result?.success) {
                        showNotification(`⚔️ Vos troupes ont conquis le territoire!`, 'battle');
                    } else {
                        showNotification(`❌ Vos troupes ont été repoussées!`, 'error');
                    }
                } else if (data.captured) {
                    showNotification(`🏴 Territoire capturé! Vos troupes sont arrivées.`);
                } else {
                    showNotification(`✅ Vos troupes sont arrivées à destination!`);
                }
                updateMovingUnitsDisplay();
                updateMovingMarkers();
            });
            
            socket.on('chat_message', (msg) => {
                addChatMessage(msg);
            });
            
            // Leaderboard update
            socket.on('leaderboard_update', (players) => {
                updateLeaderboard(players);
            });
            
            // Événements globaux
            socket.on('global_event', (event) => {
                handleGlobalEvent(event);
            });
            
            socket.on('player_joined', (data) => {
                showNotification(`👋 ${data.name} a rejoint l'équipe ${data.team}`);
            });
            
            socket.on('player_left', (data) => {
                showNotification(`👤 ${data.name} a quitté la partie`);
            });
            
            socket.on('error', (data) => {
                showNotification(`❌ ${data.message}`, 'error');
            });
            
            // Construction démarrée
            socket.on('construction_started', (data) => {
                const buildingConfig = gameData.config.BUILDINGS[data.buildingType];
                showNotification(`🏗️ Construction de ${buildingConfig.name} démarrée!`);
                gameData.player.resources = data.resources;
                updateResourcesDisplay();
                
                // Mettre à jour le builder
                if (selectedTerritory !== null) {
                    const territory = gameData.territories[selectedTerritory];
                    const builder = territory.units?.find(u => u.id === data.builderId);
                    if (builder) {
                        builder.isBuilding = true;
                        builder.buildingEndTime = data.endTime;
                        updateUnitsList(territory);
                        if (selectedBuilder && selectedBuilder.id === data.builderId) {
                            showBuildPanel(builder, territory);
                        }
                    }
                }
            });
            
            // Bâtiment terminé
            socket.on('building_completed', (data) => {
                const buildingConfig = gameData.config.BUILDINGS[data.building.type];
                showNotification(`🏗️ ${buildingConfig.name} construit!`);
                
                // Mettre à jour le territoire
                const territory = gameData.territories[data.territoryId];
                if (territory) {
                    territory.buildings = territory.buildings || [];
                    territory.buildings.push(data.building);
                    
                    // Mettre à jour le builder
                    const builder = territory.units?.find(u => u.id === selectedBuilder?.id);
                    if (builder) {
                        builder.isBuilding = false;
                    }
                    
                    if (selectedTerritory === data.territoryId) {
                        updateTerritoryInfo(territory);
                    }
                }
            });
            
            // Bâtiment détruit (lors d'une capture ennemie)
            socket.on('building_destroyed', (data) => {
                showNotification(`💥 Votre ${data.buildingName} sur ${data.territoryName} a été détruit!`, 'error');
            });
            
            // Joueur éliminé
            socket.on('player_eliminated', (data) => {
                showNotification(`💀 ${data.playerName} a été éliminé!`, 'battle');
            });
            
            // MOI éliminé
            socket.on('you_eliminated', (data) => {
                gameData.player.eliminated = true;
                showEliminationModal(data.message);
            });
            
            // Changement de météo
            socket.on('weather_change', (data) => {
                currentWeather = data.weather;
                updateWeatherDisplay(data.weather);
                const effect = data.effect;
                showNotification(`🌤️ Météo: ${effect.name}`, 'info');
            });
            
            // Technologie recherchée
            socket.on('technology_researched', (data) => {
                playerTechnologies = data.technologies;
                showNotification(`🔬 Technologie débloquée: ${getTechName(data.techName)}!`);
                initTechButtons();
            });
        }
        
        // ==================== MÉTÉO ====================
        function updateWeatherDisplay(weather) {
            const indicator = document.getElementById('weather-indicator');
            const effects = {
                sunny: '☀️ Ensoleillé',
                rainy: '🌧️ Pluie (-30% vitesse)',
                stormy: '⛈️ Tempête (-50% vitesse)',
                night: '🌙 Nuit (-50% vision)'
            };
            indicator.textContent = effects[weather] || effects.sunny;
            
            // Appliquer effet visuel
            const container = document.getElementById('map-container');
            container.classList.remove('sunny', 'rainy', 'stormy', 'night');
            container.classList.add(weather);
        }
        
        // ==================== GUERRE/PAIX ====================
        function updateWarPeaceDisplay() {
            const indicator = document.getElementById('war-peace-indicator');
            const stateName = indicator.querySelector('.state-name');
            const stateTimer = indicator.querySelector('.state-timer');
            const stateBonus = indicator.querySelector('.state-bonus');
            
            if (warPeaceState.isWar) {
                indicator.classList.remove('peace');
                indicator.classList.add('war');
                stateName.textContent = '⚔️ GUERRE';
                stateBonus.textContent = '🗡️ Attaques autorisées sur tous les territoires';
            } else {
                indicator.classList.remove('war');
                indicator.classList.add('peace');
                stateName.textContent = '🕊️ PAIX';
                stateBonus.textContent = '⚡ Vitesse x5 | 🏳️ Territoires neutres uniquement';
            }
            
            // Timer sera mis à jour par l'intervalle
        }
        
        // Mettre à jour le timer guerre/paix chaque seconde
        setInterval(() => {
            const indicator = document.getElementById('war-peace-indicator');
            if (!indicator) return;
            
            const stateTimer = indicator.querySelector('.state-timer');
            const remaining = warPeaceState.nextChange - Date.now();
            
            if (remaining > 0) {
                const hours = Math.floor(remaining / (60 * 60 * 1000));
                const minutes = Math.floor((remaining % (60 * 60 * 1000)) / (60 * 1000));
                const seconds = Math.floor((remaining % (60 * 1000)) / 1000);
                
                const nextState = warPeaceState.isWar ? '🕊️ Paix' : '⚔️ Guerre';
                stateTimer.textContent = `${nextState} dans: ${hours}h ${minutes.toString().padStart(2, '0')}m ${seconds.toString().padStart(2, '0')}s`;
            }
        }, 1000);
        
        // ==================== TECHNOLOGIES ====================
        function getTechName(techKey) {
            const names = {
                improvedAttack: '⚔️ Attaque améliorée (+20%)',
                improvedDefense: '🛡️ Défense améliorée (+20%)',
                improvedSpeed: '⚡ Vitesse améliorée (+30%)',
                improvedVision: '👁️ Vision améliorée (+1 portée)',
                improvedHeal: '💚 Soins améliorés (+50%)'
            };
            return names[techKey] || techKey;
        }
        
        function initTechButtons() {
            const container = document.getElementById('tech-buttons');
            container.innerHTML = '';
            
            const techs = {
                improvedAttack: { name: '⚔️ Attaque +20%', cost: { gold: 500, food: 100 } },
                improvedDefense: { name: '🛡️ Défense +20%', cost: { gold: 500, food: 100 } },
                improvedSpeed: { name: '⚡ Vitesse +30%', cost: { gold: 400, food: 150 } },
                improvedVision: { name: '👁️ Vision +1', cost: { gold: 300, food: 50 } },
                improvedHeal: { name: '💚 Soins +50%', cost: { gold: 350, food: 80 } }
            };
            
            Object.entries(techs).forEach(([key, tech]) => {
                const btn = document.createElement('button');
                btn.className = `tech-btn ${playerTechnologies[key] ? 'researched' : ''}`;
                btn.innerHTML = `
                    <div style="font-weight: bold;">${tech.name}</div>
                    <div style="font-size: 11px; color: #888;">💰${tech.cost.gold} 🍖${tech.cost.food}</div>
                `;
                
                if (playerTechnologies[key]) {
                    btn.disabled = true;
                    btn.innerHTML += '<div style="color: #27ae60; font-size: 11px;">✓ Recherché</div>';
                } else {
                    btn.disabled = gameData.player.resources.gold < tech.cost.gold || 
                                   gameData.player.resources.food < tech.cost.food;
                    btn.addEventListener('click', () => researchTechnology(key));
                }
                
                container.appendChild(btn);
            });
        }
        
        function researchTechnology(techName) {
            socket.emit('research_technology', { techName });
        }
        
        // Modal d'élimination
        function showEliminationModal(message) {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content" style="border-color: #e74c3c;">
                    <h1 style="color: #e74c3c;">💀 ÉLIMINÉ</h1>
                    <h2>${message}</h2>
                    <p style="color: #888; margin: 20px 0;">Votre base a été détruite. Vos troupes et bâtiments ont été supprimés.</p>
                    <button onclick="location.reload()" style="background: linear-gradient(45deg, #e74c3c, #c0392b);">
                        🔄 Rejouer
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        // ==================== INITIALISATION ====================
        function initGame() {
            // Afficher le badge d'équipe
            const badge = document.getElementById('player-badge');
            
            if (isSpectator) {
                badge.textContent = '👁️ SPECTATEUR';
                badge.style.background = 'linear-gradient(45deg, #9b59b6, #8e44ad)';
                badge.className = 'team-badge';
            } else {
                badge.textContent = `ÉQUIPE ${gameData.player.team.toUpperCase()}`;
                badge.className = `team-badge team-${gameData.player.team}`;
            }
            
            document.getElementById('player-display-name').textContent = gameData.player.name;
            
            // Initialiser les ressources
            updateResourcesDisplay();
            updateTeamsDisplay();
            
            // Générer la carte
            generateMap();
            
            // Initialiser les boutons d'unités
            initUnitButtons();
            
            // Initialiser la minimap
            initMinimap();
            
            // Initialiser les contrôles
            initControls();
            
            // Initialiser les sons
            initSounds();
            
            // Initialiser les raccourcis clavier avancés
            initAdvancedControls();
            
            // Initialiser le chat
            initChat();
            
            // Initialiser les technologies
            initTechButtons();
            
            // Initialiser les boutons d'aide et stats
            initHelpAndStats();
            
            // Mettre à jour l'UI
            updateUI();
            
            // Appliquer le brouillard de guerre initial
            updateFogOfWar();
        }
        
        // ==================== AIDE ET STATISTIQUES ====================
        let playerStats = {
            battlesWon: 0,
            battlesLost: 0,
            unitsKilled: 0,
            unitsLost: 0,
            territoriesCaptured: 0,
            buildingsBuilt: 0,
            totalGoldEarned: 0
        };
        
        function initHelpAndStats() {
            // Bouton Aide
            document.getElementById('help-btn').addEventListener('click', () => {
                document.getElementById('help-modal').classList.remove('hidden');
            });
            
            // Bouton Stats
            document.getElementById('stats-btn').addEventListener('click', () => {
                updateStatsDisplay();
                document.getElementById('stats-modal').classList.remove('hidden');
            });
            
            // Fermer avec Escape
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    document.getElementById('help-modal').classList.add('hidden');
                    document.getElementById('stats-modal').classList.add('hidden');
                }
            });
        }
        
        function updateStatsDisplay() {
            document.getElementById('stat-wins').textContent = playerStats.battlesWon;
            document.getElementById('stat-losses').textContent = playerStats.battlesLost;
            document.getElementById('stat-kills').textContent = playerStats.unitsKilled;
            document.getElementById('stat-deaths').textContent = playerStats.unitsLost;
            document.getElementById('stat-territories').textContent = playerStats.territoriesCaptured;
            document.getElementById('stat-buildings').textContent = playerStats.buildingsBuilt;
            document.getElementById('stat-gold').textContent = playerStats.totalGoldEarned;
        }
        
        // ==================== GROUPES DE CONTRÔLE (Ctrl+1 à 9) ====================
        function initAdvancedControls() {
            document.addEventListener('keydown', (e) => {
                // Groupes de contrôle: Ctrl+1-9 pour sauvegarder, 1-9 pour rappeler
                if (e.key >= '1' && e.key <= '9') {
                    const groupNum = e.key;
                    
                    if (e.ctrlKey) {
                        // Sauvegarder le groupe de contrôle
                        e.preventDefault();
                        saveControlGroup(groupNum);
                    } else if (!e.altKey && !e.shiftKey) {
                        // Rappeler le groupe de contrôle (seulement si pas dans un input)
                        if (document.activeElement.tagName !== 'INPUT') {
                            e.preventDefault();
                            recallControlGroup(groupNum);
                        }
                    }
                }
                
                // Sélectionner toutes les unités avec Ctrl+A
                if (e.ctrlKey && e.key === 'a' && document.activeElement.tagName !== 'INPUT') {
                    e.preventDefault();
                    selectAllUnits();
                }
                
                // Toggle son avec M
                if (e.key === 'm' && document.activeElement.tagName !== 'INPUT') {
                    soundEnabled = !soundEnabled;
                    showNotification(soundEnabled ? '🔊 Sons activés' : '🔇 Sons désactivés');
                }
            });
        }
        
        function saveControlGroup(groupNum) {
            if (selectedUnits.size === 0) {
                showNotification(`❌ Sélectionnez des unités d'abord!`, 'error');
                return;
            }
            
            controlGroups[groupNum] = {
                unitIds: Array.from(selectedUnits),
                territoryId: selectedTerritory
            };
            
            showNotification(`✅ Groupe ${groupNum} sauvegardé (${selectedUnits.size} unités)`);
        }
        
        function recallControlGroup(groupNum) {
            const group = controlGroups[groupNum];
            if (!group || group.unitIds.length === 0) {
                showNotification(`❌ Groupe ${groupNum} vide`, 'error');
                return;
            }
            
            // Trouver où sont les unités maintenant
            let foundTerritory = null;
            for (const territory of gameData.territories) {
                if (territory.units) {
                    const foundUnit = territory.units.find(u => group.unitIds.includes(u.id));
                    if (foundUnit) {
                        foundTerritory = territory;
                        break;
                    }
                }
            }
            
            if (!foundTerritory) {
                showNotification(`❌ Unités du groupe ${groupNum} introuvables (détruites?)`, 'error');
                controlGroups[groupNum] = null;
                return;
            }
            
            // Sélectionner le territoire et les unités
            selectedTerritory = foundTerritory.id;
            selectedUnits.clear();
            
            // Ne sélectionner que les unités qui existent encore
            foundTerritory.units.forEach(u => {
                if (group.unitIds.includes(u.id) && u.ownerId === gameData.player.oderId) {
                    selectedUnits.add(u.id);
                }
            });
            
            // Centrer la carte sur le territoire
            centerMapOnTerritory(foundTerritory.id);
            
            // Mettre à jour l'UI
            updateUI();
            updateTerritoryInfo(foundTerritory);
            document.querySelectorAll('.territory.selected').forEach(el => el.classList.remove('selected'));
            mapSvg.querySelector(`[data-id="${foundTerritory.id}"]`)?.classList.add('selected');
            
            showNotification(`📍 Groupe ${groupNum} rappelé (${selectedUnits.size} unités)`);
        }
        
        function selectAllUnits() {
            if (selectedTerritory === null) return;
            
            const territory = gameData.territories[selectedTerritory];
            if (!territory || !territory.units) return;
            
            selectedUnits.clear();
            territory.units.forEach(u => {
                if (u.ownerId === gameData.player.oderId) {
                    selectedUnits.add(u.id);
                }
            });
            
            updateUnitsList(territory);
            showNotification(`✅ ${selectedUnits.size} unités sélectionnées`);
        }
        
        function centerMapOnTerritory(territoryId) {
            const territory = gameData.territories[territoryId];
            if (!territory) return;
            
            const containerRect = mapContainer.getBoundingClientRect();
            mapState.offsetX = containerRect.width / 2 - territory.centerX * mapState.scale;
            mapState.offsetY = containerRect.height / 2 - territory.centerY * mapState.scale;
            updateMapTransform();
            updateMinimap();
        }
        
        // Fonction pour mettre à jour les stats après événements
        function recordStat(type, value = 1) {
            switch(type) {
                case 'battle_won': playerStats.battlesWon += value; break;
                case 'battle_lost': playerStats.battlesLost += value; break;
                case 'kill': playerStats.unitsKilled += value; break;
                case 'death': playerStats.unitsLost += value; break;
                case 'capture': playerStats.territoriesCaptured += value; break;
                case 'build': playerStats.buildingsBuilt += value; break;
                case 'gold': playerStats.totalGoldEarned += value; break;
            }
        }
        
        // ==================== LEADERBOARD ====================
        let leaderboardData = [];
        
        function updateLeaderboard(players) {
            leaderboardData = players;
            renderLeaderboard();
        }
        
        function renderLeaderboard() {
            const container = document.getElementById('leaderboard-list');
            if (!container) return;
            
            // Les joueurs sont déjà triés par score côté serveur
            // Système de points:
            // Territoires = 2 pts, Bâtiments = 1 pt, Unités = 0.2 pt, Kills = 1 pt
            const scoredPlayers = leaderboardData.slice(0, 10);
            
            container.innerHTML = '';
            
            scoredPlayers.forEach((player, idx) => {
                const div = document.createElement('div');
                div.className = `leaderboard-item ${player.id === gameData.player?.oderId ? 'me' : ''}`;
                
                const rankEmoji = idx === 0 ? '🥇' : idx === 1 ? '🥈' : idx === 2 ? '🥉' : `${idx + 1}.`;
                const teamColor = {
                    red: '#e74c3c',
                    blue: '#3498db',
                    green: '#27ae60',
                    yellow: '#f39c12'
                }[player.team] || '#888';
                
                // Afficher les détails des stats
                const details = `🏴${player.territories || 0} 🏠${player.buildings || 0} 👥${player.units || 0} ☠️${player.kills || 0}`;
                
                div.innerHTML = `
                    <span>
                        <span class="leaderboard-rank">${rankEmoji}</span>
                        <span style="color: ${teamColor};">●</span>
                        ${player.name}
                    </span>
                    <span title="${details}">${player.score || 0} pts</span>
                `;
                container.appendChild(div);
            });
            
            if (scoredPlayers.length === 0) {
                container.innerHTML = '<div style="color: #666; text-align: center; padding: 10px;">Aucun joueur</div>';
            }
        }
        
        // ==================== ÉVÉNEMENTS GLOBAUX ====================
        function handleGlobalEvent(event) {
            let message = '';
            let type = 'info';
            
            switch(event.type) {
                case 'territory_captured':
                    message = `🏴 ${event.playerName} (${event.team}) a capturé ${event.territoryName}!`;
                    if (event.team !== gameData.player.team) type = 'battle';
                    recordStat('capture');
                    break;
                    
                case 'base_destroyed':
                    message = `💀 ${event.attackerName} a détruit la base de ${event.victimName}!`;
                    type = 'battle';
                    break;
                    
                case 'building_completed':
                    if (event.team === gameData.player.team) {
                        message = `🏗️ ${event.playerName} a construit ${event.buildingName}`;
                        recordStat('build');
                    }
                    break;
                    
                case 'major_battle':
                    message = `⚔️ Grande bataille sur ${event.territoryName}! ${event.attackerTeam} vs ${event.defenderTeam}`;
                    type = 'battle';
                    break;
                    
                case 'team_dominance':
                    message = `👑 L'équipe ${event.team} domine avec ${event.territories} territoires!`;
                    type = 'info';
                    break;
            }
            
            if (message) {
                showNotification(message, type);
            }
        }
        
        // ==================== GÉNÉRATION DE CARTE VORONOI ====================
        let territoryShapes = null; // Cache pour les formes
        
        // Algorithme Voronoi - trouve le territoire le plus proche d'un point
        function findClosestTerritory(x, y, territories) {
            let minDist = Infinity;
            let closest = 0;
            for (let i = 0; i < territories.length; i++) {
                const dx = x - territories[i].centerX;
                const dy = y - territories[i].centerY;
                const dist = dx * dx + dy * dy;
                if (dist < minDist) {
                    minDist = dist;
                    closest = i;
                }
            }
            return closest;
        }
        
        // Créer les polygones Voronoi (frontières naturelles)
        function computeTerritoryShapes(territories) {
            const shapes = [];
            const numRays = 64; // Plus de rayons = frontières plus lisses
            
            territories.forEach((territory, idx) => {
                const points = [];
                
                for (let r = 0; r < numRays; r++) {
                    const angle = (r / numRays) * Math.PI * 2;
                    
                    // Lancer un rayon et trouver où il rencontre une frontière
                    let dist = 10;
                    const maxDist = 2000;
                    const step = 20;
                    
                    while (dist < maxDist) {
                        const testX = territory.centerX + dist * Math.cos(angle);
                        const testY = territory.centerY + dist * Math.sin(angle);
                        
                        // Vérifier si on est sorti des limites
                        if (testX < 0 || testX > MAP_WIDTH || testY < 0 || testY > MAP_HEIGHT) {
                            break;
                        }
                        
                        // Vérifier si on est entré dans un autre territoire
                        const closest = findClosestTerritory(testX, testY, territories);
                        if (closest !== idx) {
                            dist -= step / 2; // Reculer un peu
                            break;
                        }
                        
                        dist += step;
                    }
                    
                    // Ajouter le point de frontière
                    const px = territory.centerX + dist * Math.cos(angle);
                    const py = territory.centerY + dist * Math.sin(angle);
                    points.push({
                        x: Math.max(0, Math.min(MAP_WIDTH, px)),
                        y: Math.max(0, Math.min(MAP_HEIGHT, py))
                    });
                }
                
                shapes.push(points);
            });
            
            return shapes;
        }
        
        // Fonction pour générer une position aléatoire sur un territoire
        function getRandomPositionOnTerritory(territory, idx, seed = 0) {
            if (!territoryShapes || !territoryShapes[territory.id]) {
                // Fallback: position près du centre
                const angle = (seed * 137.5) % 360 * (Math.PI / 180);
                const dist = 80 + (seed * 31) % 150;
                return {
                    x: territory.centerX + Math.cos(angle) * dist,
                    y: territory.centerY + Math.sin(angle) * dist
                };
            }
            
            const points = territoryShapes[territory.id];
            // Utiliser le seed pour générer une position pseudo-aléatoire mais stable
            const seedVal = seed * 12345 + territory.id * 6789;
            const angle = (seedVal % 360) * (Math.PI / 180);
            const maxDist = 200;
            const dist = 60 + (seedVal % maxDist);
            
            return {
                x: territory.centerX + Math.cos(angle) * dist,
                y: territory.centerY + Math.sin(angle) * dist
            };
        }
        
        // Fonction pour créer les marqueurs de bâtiments d'un territoire
        function createBuildingMarkers(territory) {
            const markers = [];
            let markerIndex = 0;
            
            // Bases multiples - utiliser territory.bases si disponible, sinon fallback sur territory.base
            const bases = territory.bases || (territory.base ? [territory.base] : []);
            bases.forEach((base, baseIdx) => {
                const pos = getRandomPositionOnTerritory(territory, markerIndex++, (base.playerId?.charCodeAt(0) || 1) + baseIdx * 100);
                const baseMarker = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                baseMarker.setAttribute('x', pos.x);
                baseMarker.setAttribute('y', pos.y);
                baseMarker.setAttribute('class', 'base-marker');
                baseMarker.setAttribute('data-territory', territory.id);
                baseMarker.setAttribute('data-base-index', baseIdx);
                baseMarker.setAttribute('text-anchor', 'middle');
                baseMarker.setAttribute('dominant-baseline', 'central');
                baseMarker.setAttribute('font-size', '80');
                baseMarker.setAttribute('pointer-events', 'none');
                baseMarker.textContent = '🏰';
                markers.push(baseMarker);
            });
            
            // Autres bâtiments
            if (territory.buildings && territory.buildings.length > 0) {
                territory.buildings.forEach((building, bIdx) => {
                    const buildingConfig = gameData.config.BUILDINGS[building.type];
                    if (buildingConfig) {
                        const pos = getRandomPositionOnTerritory(territory, markerIndex++, building.id || bIdx * 999);
                        const buildingMarker = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        buildingMarker.setAttribute('x', pos.x);
                        buildingMarker.setAttribute('y', pos.y);
                        buildingMarker.setAttribute('class', 'building-marker');
                        buildingMarker.setAttribute('data-territory', territory.id);
                        buildingMarker.setAttribute('text-anchor', 'middle');
                        buildingMarker.setAttribute('dominant-baseline', 'central');
                        buildingMarker.setAttribute('font-size', '60');
                        buildingMarker.setAttribute('pointer-events', 'none');
                        buildingMarker.textContent = buildingConfig.icon || '🏠';
                        markers.push(buildingMarker);
                    }
                });
            }
            
            return markers;
        }
        
        function generateMap() {
            // Configurer le SVG avec les bonnes dimensions
            mapSvg.setAttribute('width', MAP_WIDTH);
            mapSvg.setAttribute('height', MAP_HEIGHT);
            mapSvg.setAttribute('viewBox', `0 0 ${MAP_WIDTH} ${MAP_HEIGHT}`);
            mapSvg.innerHTML = '';
            
            // Debug
            console.log('generateMap - Territoires:', gameData.territories.length);
            if (gameData.territories[0]) {
                console.log('Premier territoire:', gameData.territories[0].name, 
                    'à', gameData.territories[0].centerX, gameData.territories[0].centerY);
            }
            
            // Calculer les formes Voronoi une seule fois
            if (!territoryShapes) {
                console.log('Calcul des polygones Voronoi...');
                territoryShapes = computeTerritoryShapes(gameData.territories);
                console.log('Voronoi calculé!');
            }
            
            // Dessiner les territoires
            gameData.territories.forEach((territory, idx) => {
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                const points = territoryShapes[idx];
                
                polygon.setAttribute('points', points.map(p => `${p.x},${p.y}`).join(' '));
                // Vérifier si c'est le territoire de notre base
                const isMyBase = territory.base && gameData.player && (territory.base.ownerId === gameData.player.oderId || territory.base.playerId === gameData.player.oderId);
                polygon.setAttribute('class', `territory ${territory.team ? 'team-' + territory.team : 'neutral'}${isMyBase ? ' my-base' : ''}`);
                polygon.setAttribute('data-id', territory.id);
                
                polygon.addEventListener('click', (e) => {
                    e.stopPropagation();
                    onTerritoryClick(territory.id, e);
                });
                
                mapSvg.appendChild(polygon);
                
                // Ajouter l'icône de terrain dans le coin du territoire
                const terrain = TERRAIN_INFO[territory.terrain] || TERRAIN_INFO.plains;
                if (territory.terrain && territory.terrain !== 'plains') {
                    const terrainIcon = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    terrainIcon.setAttribute('x', territory.centerX - 100);
                    terrainIcon.setAttribute('y', territory.centerY - 60);
                    terrainIcon.setAttribute('class', 'terrain-marker');
                    terrainIcon.setAttribute('text-anchor', 'middle');
                    terrainIcon.setAttribute('font-size', '45');
                    terrainIcon.setAttribute('fill', terrain.color);
                    terrainIcon.setAttribute('pointer-events', 'none');
                    terrainIcon.setAttribute('data-territory', territory.id);
                    terrainIcon.textContent = terrain.icon;
                    mapSvg.appendChild(terrainIcon);
                }
            });
            
            // Ajouter les marqueurs par-dessus
            gameData.territories.forEach(territory => {
                // Marqueurs de bâtiments (bases + autres) à positions aléatoires
                const buildingMarkers = createBuildingMarkers(territory);
                buildingMarkers.forEach(marker => mapSvg.appendChild(marker));
                
                // Marqueur d'unités si présentes - affiche le nombre par type
                if (territory.units && territory.units.length > 0) {
                    // Compter les unités par type
                    const unitCounts = {};
                    territory.units.forEach(u => {
                        unitCounts[u.type] = (unitCounts[u.type] || 0) + 1;
                    });
                    
                    // Créer un texte avec les icônes et nombres
                    let unitText = '';
                    Object.entries(unitCounts).forEach(([type, count]) => {
                        const icon = gameData.config.UNITS[type]?.icon || '⚔️';
                        unitText += `${icon}${count} `;
                    });
                    
                    const unitMarker = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    unitMarker.setAttribute('x', territory.centerX);
                    unitMarker.setAttribute('y', territory.centerY + 80);
                    unitMarker.setAttribute('class', 'unit-marker');
                    unitMarker.setAttribute('data-territory', territory.id);
                    unitMarker.setAttribute('text-anchor', 'middle');
                    unitMarker.setAttribute('font-size', '50');
                    unitMarker.setAttribute('fill', '#fff');
                    unitMarker.setAttribute('pointer-events', 'none');
                    unitMarker.textContent = unitText.trim();
                    mapSvg.appendChild(unitMarker);
                }
                
                // Nom du territoire
                const nameLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                nameLabel.setAttribute('x', territory.centerX);
                nameLabel.setAttribute('y', territory.centerY);
                nameLabel.setAttribute('class', 'territory-label');
                nameLabel.setAttribute('data-territory', territory.id);
                nameLabel.setAttribute('text-anchor', 'middle');
                nameLabel.setAttribute('dominant-baseline', 'central');
                nameLabel.setAttribute('fill', 'rgba(255,255,255,0.8)');
                nameLabel.setAttribute('font-size', '60');
                nameLabel.setAttribute('font-weight', 'bold');
                nameLabel.setAttribute('pointer-events', 'none');
                nameLabel.textContent = territory.name.substring(0, 12);
                mapSvg.appendChild(nameLabel);
            });
            
            // Appliquer la sélection si nécessaire
            if (selectedTerritory !== null) {
                const polygon = mapSvg.querySelector(`[data-id="${selectedTerritory}"]`);
                if (polygon) polygon.classList.add('selected');
            }
            
            updateMapTransform();
        }
        
        function updateTerritoryDisplay(territoryId) {
            const territory = gameData.territories[territoryId];
            const polygon = mapSvg.querySelector(`[data-id="${territoryId}"]`);
            
            if (polygon) {
                // Vérifier si c'est le territoire de notre base
                const isMyBase = territory.base && gameData.player && (territory.base.ownerId === gameData.player.oderId || territory.base.playerId === gameData.player.oderId);
                // Mettre à jour la classe du polygone
                polygon.className.baseVal = `territory ${territory.team ? 'team-' + territory.team : 'neutral'}${isMyBase ? ' my-base' : ''}`;
                if (selectedTerritory === territoryId) {
                    polygon.classList.add('selected');
                }
            }
            
            // Supprimer les anciens marqueurs pour ce territoire et les recréer
            const markers = mapSvg.querySelectorAll(`[data-territory="${territoryId}"]`);
            markers.forEach(m => m.remove());
            
            // Vérifier si ce territoire est visible (brouillard de guerre)
            const visibleTerritories = isSpectator ? null : getVisibleTerritories();
            const isVisible = !visibleTerritories || visibleTerritories.has(territoryId);
            
            // Ajouter les nouveaux marqueurs de bâtiments (base + tous les bâtiments)
            const buildingMarkers = createBuildingMarkers(territory);
            buildingMarkers.forEach(marker => {
                if (!isVisible) marker.style.display = 'none';
                mapSvg.appendChild(marker);
            });
            
            if (territory.units && territory.units.length > 0) {
                // Compter les unités par type
                const unitCounts = {};
                territory.units.forEach(u => {
                    unitCounts[u.type] = (unitCounts[u.type] || 0) + 1;
                });
                
                // Créer un texte avec les icônes et nombres
                let unitText = '';
                Object.entries(unitCounts).forEach(([type, count]) => {
                    const icon = gameData.config.UNITS[type]?.icon || '⚔️';
                    unitText += `${icon}${count} `;
                });
                
                const unitMarker = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                unitMarker.setAttribute('x', territory.centerX);
                unitMarker.setAttribute('y', territory.centerY + 80);
                unitMarker.setAttribute('class', 'unit-marker');
                unitMarker.setAttribute('data-territory', territoryId);
                unitMarker.setAttribute('text-anchor', 'middle');
                unitMarker.setAttribute('font-size', '50');
                unitMarker.setAttribute('fill', '#fff');
                unitMarker.setAttribute('pointer-events', 'none');
                unitMarker.textContent = unitText.trim();
                if (!isVisible) unitMarker.style.display = 'none';
                mapSvg.appendChild(unitMarker);
            }
            
            if (selectedTerritory === territoryId) {
                updateTerritoryInfo(territory);
            }
        }
        
        // ==================== CONTRÔLES DE LA CARTE ====================
        function initControls() {
            mapContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.max(0.01, Math.min(0.5, mapState.scale * delta));
                
                // Zoom vers la souris
                const rect = mapContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                mapState.offsetX = mouseX - (mouseX - mapState.offsetX) * (newScale / mapState.scale);
                mapState.offsetY = mouseY - (mouseY - mapState.offsetY) * (newScale / mapState.scale);
                mapState.scale = newScale;
                
                updateMapTransform();
                updateMinimap();
            });
            
            mapContainer.addEventListener('mousedown', (e) => {
                if (e.button === 0) {
                    mapState.isDragging = true;
                    mapState.lastX = e.clientX;
                    mapState.lastY = e.clientY;
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (mapState.isDragging) {
                    mapState.offsetX += e.clientX - mapState.lastX;
                    mapState.offsetY += e.clientY - mapState.lastY;
                    mapState.lastX = e.clientX;
                    mapState.lastY = e.clientY;
                    updateMapTransform();
                    updateMinimap();
                }
            });
            
            document.addEventListener('mouseup', () => {
                mapState.isDragging = false;
            });
        }
        
        function updateMapTransform() {
            mapSvg.style.transform = `translate(${mapState.offsetX}px, ${mapState.offsetY}px) scale(${mapState.scale})`;
            mapSvg.style.transformOrigin = '0 0';
        }
        
        // Centrer la vue sur notre base
        function centerOnMyBase() {
            if (!gameData.player) return;
            
            // Trouver le territoire avec notre base (vérifier ownerId ET playerId)
            const myBaseTerritory = gameData.territories.find(t => 
                t.base && (t.base.ownerId === gameData.player.oderId || t.base.playerId === gameData.player.oderId)
            );
            
            if (!myBaseTerritory) {
                console.log('DEBUG centerOnMyBase - player.oderId:', gameData.player.oderId);
                console.log('DEBUG centerOnMyBase - bases trouvées:', gameData.territories.filter(t => t.base).map(t => ({id: t.id, ownerId: t.base.ownerId, playerId: t.base.playerId})));
                showNotification('❌ Vous n\'avez pas encore de base!', 'error');
                return;
            }
            
            // Centrer la vue sur ce territoire
            const containerRect = mapContainer.getBoundingClientRect();
            const centerX = containerRect.width / 2;
            const centerY = containerRect.height / 2;
            
            mapState.offsetX = centerX - myBaseTerritory.centerX * mapState.scale;
            mapState.offsetY = centerY - myBaseTerritory.centerY * mapState.scale;
            
            updateMapTransform();
            updateMinimap();
            
            // Sélectionner le territoire
            onTerritoryClick(myBaseTerritory.id);
            
            showNotification('📍 Centré sur votre base!', 'info');
        }
        
        // ==================== CLIC SUR TERRITOIRE ====================
        function onTerritoryClick(territoryId, event) {
            // Bloquer toute interaction en mode spectateur
            if (isSpectator) return;
            
            const territory = gameData.territories[territoryId];
            const shiftKey = event?.shiftKey || false;
            
            // Mode waypoint avec Shift+clic
            if (shiftKey && selectedUnits.size > 0 && selectedTerritory !== null) {
                handleWaypointClick(territoryId);
                return;
            }
            
            // Mode placement de base
            if (!gameData.player.hasBase) {
                // Permet de placer sur territoire de l'équipe (plusieurs bases possibles par territoire)
                if (territory.team === gameData.player.team) {
                    socket.emit('place_base', { territoryId });
                } else {
                    showNotification('❌ Placez votre base sur un territoire de votre équipe!', 'error');
                }
                return;
            }
            
            // Mode sélection de chemin (multi-cases)
            if (pathMode && selectedUnits.size > 0) {
                const lastTerritoryId = currentPath[currentPath.length - 1];
                const lastTerritory = gameData.territories[lastTerritoryId];
                
                // Vérifier si le territoire est adjacent au dernier du chemin
                if (lastTerritory.neighbors.includes(territoryId)) {
                    // Ajouter au chemin
                    currentPath.push(territoryId);
                    updatePathDisplay();
                    showNotification(`📍 Chemin: ${currentPath.length - 1} étapes. Clic droit pour confirmer, ESC pour annuler.`);
                } else {
                    showNotification('❌ Ce territoire n\'est pas adjacent!', 'error');
                }
                return;
            }
            
            // Mode attaque artillerie longue portée
            if (artilleryMode && selectedUnits.size > 0) {
                const inRange = getTerritoriesInRange(selectedTerritory, 2);
                const targetInRange = inRange.find(t => t.id === territoryId);
                
                if (targetInRange && territory.team && territory.team !== gameData.player.team) {
                    // Attaque artillerie à distance
                    socket.emit('artillery_attack', {
                        unitIds: Array.from(selectedUnits),
                        fromTerritoryId: selectedTerritory,
                        toTerritoryId: territoryId
                    });
                    artilleryMode = false;
                    updateHighlightedTerritories();
                } else {
                    showNotification('❌ Cible hors de portée ou non ennemie!', 'error');
                }
                return;
            }
            
            // Mode déplacement simple (1 case adjacente)
            if (moveMode && selectedUnits.size > 0) {
                const fromTerritory = gameData.territories[selectedTerritory];
                if (fromTerritory.neighbors.includes(territoryId)) {
                    socket.emit('move_units', {
                        unitIds: Array.from(selectedUnits),
                        fromTerritoryId: selectedTerritory,
                        toTerritoryId: territoryId,
                        path: [selectedTerritory, territoryId]
                    });
                } else {
                    showNotification('❌ Territoires non adjacents! Utilisez "Tracer chemin" pour plusieurs cases.', 'error');
                }
                moveMode = false;
                updateHighlightedTerritories();
                return;
            }
            
            // Sélection normale
            selectedTerritory = territoryId;
            selectedUnits.clear();
            
            // Réinitialiser les panneaux pour ce territoire
            updateLeftPanelForTerritory(territory);
            
            updateUI();
            updateTerritoryInfo(territory);
            
            // Highlight
            document.querySelectorAll('.territory.selected').forEach(el => el.classList.remove('selected'));
            mapSvg.querySelector(`[data-id="${territoryId}"]`)?.classList.add('selected');
        }
        
        // Mettre à jour le panneau de gauche selon le territoire sélectionné
        function updateLeftPanelForTerritory(territory) {
            // Cacher tous les panneaux d'abord
            document.getElementById('production-panel').classList.add('hidden');
            document.getElementById('build-panel').classList.add('hidden');
            document.getElementById('select-base-message').classList.add('hidden');
            currentProductionTerritory = null;
            selectedBuilder = null;
            
            // Si pas de base placée, ne rien faire (le message de placement de base est déjà affiché)
            if (!gameData.player.hasBase) {
                return;
            }
            
            // Si c'est pas notre équipe, afficher le message par défaut
            if (territory.team !== gameData.player.team) {
                document.getElementById('select-base-message').classList.remove('hidden');
                return;
            }
            
            // Collecter toutes les options de production disponibles sur ce territoire
            let productionOptions = [];
            
            // 1. Vérifier si on a notre base sur ce territoire
            if (territory.base && territory.base.playerId === gameData.player.oderId) {
                productionOptions.push({
                    type: 'base',
                    name: '🏰 Base',
                    units: territory.base.canProduce || ['infantry', 'builder']
                });
            }
            
            // 2. Vérifier les bâtiments de production sur ce territoire
            if (territory.buildings && territory.buildings.length > 0) {
                territory.buildings.forEach(building => {
                    if (building.ownerId === gameData.player.oderId) {
                        const config = gameData.config.BUILDINGS[building.type];
                        if (config && config.canProduce) {
                            productionOptions.push({
                                type: building.type,
                                name: `${config.icon} ${config.name}`,
                                units: config.canProduce
                            });
                        }
                    }
                });
            }
            
            // 3. Vérifier si on a un builder sur ce territoire
            const myBuilder = territory.units?.find(u => 
                u.ownerId === gameData.player.oderId && u.type === 'builder'
            );
            
            // Afficher le panneau approprié
            if (productionOptions.length > 0) {
                // Fusionner toutes les unités disponibles
                const allUnits = [...new Set(productionOptions.flatMap(opt => opt.units))];
                const sourceName = productionOptions.map(opt => opt.name).join(' + ');
                showProductionPanel(territory.id, allUnits, sourceName);
            } else if (myBuilder) {
                // Si on a un builder mais pas de production, afficher le panneau de construction
                showBuildPanel(myBuilder, territory);
            } else {
                // Sinon afficher le message par défaut
                document.getElementById('select-base-message').classList.remove('hidden');
            }
        }
        
        // Confirmer le chemin avec clic droit
        document.addEventListener('contextmenu', (e) => {
            if (pathMode && currentPath.length > 1) {
                e.preventDefault();
                
                // Calculer le coût en nourriture
                const numUnits = selectedUnits.size;
                const numSteps = currentPath.length - 1;
                const foodCost = numUnits * numSteps * (gameData.config.FOOD_PER_MOVE || 5);
                
                // Vérifier si on a assez de nourriture
                if (gameData.player.resources.food < foodCost) {
                    showNotification(`❌ Pas assez de nourriture! Coût: ${foodCost} 🍖, Disponible: ${gameData.player.resources.food} 🍖`);
                    return;
                }
                
                socket.emit('move_units', {
                    unitIds: Array.from(selectedUnits),
                    fromTerritoryId: currentPath[0],
                    toTerritoryId: currentPath[currentPath.length - 1],
                    path: currentPath
                });
                
                showNotification(`🚶 Déplacement: -${foodCost} 🍖`);
                pathMode = false;
                currentPath = [];
                updatePathDisplay();
            }
        });
        
        // Annuler avec ESC
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (pathMode) {
                    pathMode = false;
                    currentPath = [];
                    updatePathDisplay();
                    showNotification('❌ Chemin annulé');
                }
                if (waypointMode && waypointQueue.length > 0) {
                    waypointMode = false;
                    waypointQueue = [];
                    updateWaypointDisplay();
                    showNotification('❌ Waypoints annulés');
                }
                moveMode = false;
                updateHighlightedTerritories();
            }
        });
        
        // ==================== SYSTÈME DE WAYPOINTS (Shift+clic) ====================
        function handleWaypointClick(territoryId) {
            const territory = gameData.territories[territoryId];
            const startTerritory = waypointQueue.length > 0 
                ? gameData.territories[waypointQueue[waypointQueue.length - 1]]
                : gameData.territories[selectedTerritory];
            
            // Vérifier adjacence
            if (!startTerritory.neighbors.includes(territoryId)) {
                showNotification('❌ Les waypoints doivent être adjacents!', 'error');
                return;
            }
            
            // Ajouter le waypoint
            if (waypointQueue.length === 0) {
                waypointQueue.push(selectedTerritory);
            }
            waypointQueue.push(territoryId);
            waypointMode = true;
            
            updateWaypointDisplay();
            
            const numWaypoints = waypointQueue.length - 1;
            const foodCost = selectedUnits.size * numWaypoints * (gameData.config.FOOD_PER_MOVE || 5);
            showNotification(`📍 Waypoint ${numWaypoints} ajouté (${territory.name}). Coût: ${foodCost}🍖. Clic droit pour confirmer.`);
        }
        
        function updateWaypointDisplay() {
            // Retirer les anciens marqueurs de waypoint
            document.querySelectorAll('.waypoint-marker').forEach(el => el.remove());
            document.querySelectorAll('.territory.waypoint').forEach(el => el.classList.remove('waypoint'));
            
            if (waypointQueue.length > 0) {
                waypointQueue.forEach((tId, idx) => {
                    const polygon = mapSvg.querySelector(`[data-id="${tId}"]`);
                    if (polygon) polygon.classList.add('waypoint');
                    
                    // Ajouter un numéro de waypoint
                    const territory = gameData.territories[tId];
                    if (territory && idx > 0) {
                        const marker = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        marker.setAttribute('x', territory.centerX);
                        marker.setAttribute('y', territory.centerY - 120);
                        marker.setAttribute('text-anchor', 'middle');
                        marker.setAttribute('font-size', '50');
                        marker.setAttribute('fill', '#e67e22');
                        marker.setAttribute('font-weight', 'bold');
                        marker.setAttribute('class', 'waypoint-marker');
                        marker.textContent = `📍${idx}`;
                        mapSvg.appendChild(marker);
                    }
                });
            }
        }
        
        // Confirmer les waypoints avec clic droit
        document.addEventListener('contextmenu', (e) => {
            // Waypoints
            if (waypointMode && waypointQueue.length > 1) {
                e.preventDefault();
                
                const numUnits = selectedUnits.size;
                const numSteps = waypointQueue.length - 1;
                const foodCost = numUnits * numSteps * (gameData.config.FOOD_PER_MOVE || 5);
                
                if (gameData.player.resources.food < foodCost) {
                    showNotification(`❌ Pas assez de nourriture! Coût: ${foodCost}🍖`, 'error');
                    return;
                }
                
                socket.emit('move_units', {
                    unitIds: Array.from(selectedUnits),
                    fromTerritoryId: waypointQueue[0],
                    toTerritoryId: waypointQueue[waypointQueue.length - 1],
                    path: waypointQueue
                });
                
                showNotification(`🚶 Déplacement avec ${numSteps} waypoints: -${foodCost}🍖`);
                waypointMode = false;
                waypointQueue = [];
                selectedUnits.clear();
                updateWaypointDisplay();
                return;
            }
        }, true); // Capture phase pour être avant le handler de pathMode
        
        // Afficher le chemin en cours de tracé
        function updatePathDisplay() {
            // Retirer les anciens marqueurs de chemin
            document.querySelectorAll('.path-marker').forEach(el => el.remove());
            document.querySelectorAll('.path-cost-marker').forEach(el => el.remove());
            document.querySelectorAll('.territory.in-path').forEach(el => el.classList.remove('in-path'));
            
            if (currentPath.length > 0) {
                // Marquer les territoires du chemin
                currentPath.forEach((tId, idx) => {
                    const polygon = mapSvg.querySelector(`[data-id="${tId}"]`);
                    if (polygon) polygon.classList.add('in-path');
                    
                    // Ajouter un numéro d'étape
                    const territory = gameData.territories[tId];
                    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    marker.setAttribute('x', territory.centerX);
                    marker.setAttribute('y', territory.centerY - 120);
                    marker.setAttribute('text-anchor', 'middle');
                    marker.setAttribute('font-size', '80');
                    marker.setAttribute('fill', '#4ecdc4');
                    marker.setAttribute('font-weight', 'bold');
                    marker.setAttribute('pointer-events', 'none');
                    marker.setAttribute('class', 'path-marker');
                    marker.textContent = idx === 0 ? '🚩' : `${idx}`;
                    mapSvg.appendChild(marker);
                });
                
                // Afficher le coût en nourriture au milieu du chemin
                if (currentPath.length > 1 && selectedUnits.size > 0) {
                    const numUnits = selectedUnits.size;
                    const numSteps = currentPath.length - 1;
                    const foodCost = numUnits * numSteps * (gameData.config.FOOD_PER_MOVE || 5);
                    const canAfford = gameData.player.resources.food >= foodCost;
                    
                    // Position au milieu du chemin
                    const midIdx = Math.floor(currentPath.length / 2);
                    const midTerritory = gameData.territories[currentPath[midIdx]];
                    
                    const costMarker = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    costMarker.setAttribute('x', midTerritory.centerX);
                    costMarker.setAttribute('y', midTerritory.centerY + 100);
                    costMarker.setAttribute('text-anchor', 'middle');
                    costMarker.setAttribute('font-size', '60');
                    costMarker.setAttribute('fill', canAfford ? '#2ecc71' : '#e74c3c');
                    costMarker.setAttribute('font-weight', 'bold');
                    costMarker.setAttribute('pointer-events', 'none');
                    costMarker.setAttribute('class', 'path-cost-marker');
                    costMarker.textContent = `🍖 -${foodCost}`;
                    mapSvg.appendChild(costMarker);
                }
                
                // Highlight les territoires adjacents au dernier
                const lastTerritory = gameData.territories[currentPath[currentPath.length - 1]];
                lastTerritory.neighbors.forEach(neighborId => {
                    if (!currentPath.includes(neighborId)) {
                        mapSvg.querySelector(`[data-id="${neighborId}"]`)?.classList.add('can-move');
                    }
                });
            }
        }
        
        // Configuration des terrains côté client
        const TERRAIN_INFO = {
            plains: { name: 'Plaine', icon: '🌾', color: '#7cb342', desc: 'Terrain standard' },
            mountain: { name: 'Montagne', icon: '⛰️', color: '#8d6e63', desc: '+50% défense, -40% vitesse' },
            forest: { name: 'Forêt', icon: '🌲', color: '#2e7d32', desc: 'Embuscades possibles, +20% défense' },
            river: { name: 'Rivière', icon: '🌊', color: '#1976d2', desc: '+30% défense, -50% vitesse' },
            desert: { name: 'Désert', icon: '🏜️', color: '#ffa726', desc: 'Riche en or, conditions difficiles' },
            swamp: { name: 'Marécage', icon: '🐊', color: '#5d4037', desc: 'Très lent, embuscades' }
        };
        
        function updateTerritoryInfo(territory) {
            document.getElementById('territory-name').textContent = territory.name;
            
            let details = '';
            
            // Afficher le type de terrain
            const terrain = TERRAIN_INFO[territory.terrain] || TERRAIN_INFO.plains;
            details += `<p style="background: ${terrain.color}22; padding: 5px 10px; border-radius: 5px; border-left: 3px solid ${terrain.color};">
                ${terrain.icon} <strong>${terrain.name}</strong>
                <span style="font-size: 11px; color: #888; display: block;">${terrain.desc}</span>
            </p>`;
            
            if (territory.team) {
                details += `<p>🏴 Équipe: <strong>${territory.team}</strong></p>`;
                
                // Afficher le gouverneur (propriétaire du territoire)
                if (territory.owner) {
                    // Trouver le nom du joueur propriétaire parmi toutes les équipes
                    let ownerName = 'Inconnu';
                    for (const teamName in gameData.teams) {
                        const teamData = gameData.teams[teamName];
                        if (teamData && teamData.players) {
                            const found = teamData.players.find(p => p.oderId === territory.owner);
                            if (found) {
                                ownerName = found.name;
                                break;
                            }
                        }
                    }
                    const isMe = territory.owner === gameData.player.oderId;
                    details += `<p>👑 Gouverneur: <strong style="color: ${isMe ? '#f1c40f' : '#95a5a6'};">${ownerName}${isMe ? ' (Vous)' : ''}</strong></p>`;
                }
            } else {
                details += `<p>🏴 Territoire neutre</p>`;
            }
            
            // Afficher toutes les bases du territoire
            const bases = territory.bases || (territory.base ? [territory.base] : []);
            if (bases.length > 0) {
                details += `<p><strong>🏰 Bases (${bases.length}):</strong></p>`;
                bases.forEach((base, idx) => {
                    details += `<p style="margin-left: 10px;">• Base de ${base.playerName} - ❤️ ${base.health}/${gameData.config.BASE_HEALTH}</p>`;
                    
                    // Si c'est MA base, ajouter un bouton pour produire
                    if (base.playerId === gameData.player.oderId) {
                        details += `<button onclick="openBaseProduction(${territory.id})" 
                            style="margin-top: 5px; margin-left: 10px; padding: 8px 15px; background: linear-gradient(45deg, #4ecdc4, #45b7d1); 
                            border: none; border-radius: 5px; color: white; cursor: pointer; font-weight: bold;">
                            🏭 Produire des unités
                        </button>`;
                    }
                });
            }
            
            // Afficher les bâtiments
            if (territory.buildings && territory.buildings.length > 0) {
                details += `<p style="margin-top: 10px;"><strong>🏗️ Bâtiments:</strong></p>`;
                territory.buildings.forEach(building => {
                    const config = gameData.config.BUILDINGS[building.type];
                    if (config) {
                        details += `<p>${config.icon} ${config.name}`;
                        if (building.ownerId === gameData.player.oderId && config.canProduce) {
                            details += ` <button onclick="openBuildingProduction(${territory.id}, '${building.type}')" 
                                style="padding: 4px 10px; background: #9b59b6; border: none; border-radius: 3px; 
                                color: white; cursor: pointer; font-size: 11px;">
                                🏭 Produire
                            </button>`;
                        }
                        details += `</p>`;
                    }
                });
            }
            
            // Afficher les revenus avec le pourcentage du joueur
            let revenuePercent = 0;
            let revenueColor = '#95a5a6';
            if (territory.team === gameData.player.team) {
                if (territory.owner === gameData.player.oderId) {
                    revenuePercent = 100; // Gouverneur = 100%
                    revenueColor = '#2ecc71';
                } else if (territory.owner) {
                    revenuePercent = 50; // Coéquipier = 50%
                    revenueColor = '#f39c12';
                }
            }
            
            const revenueLabel = revenuePercent > 0 ? 
                ` <span style="color: ${revenueColor}; font-size: 11px;">(${revenuePercent}% pour vous)</span>` : '';
            
            details += `<p style="margin-top: 10px;">💰 Or/tour: +${territory.resources.gold}${revenueLabel}</p>`;
            details += `<p>🍖 Nourriture/tour: +${territory.resources.food}${revenueLabel}</p>`;
            
            // Afficher les bonus de ressources si présents
            if (territory.bonusResource) {
                const bonusIcon = territory.bonusResource === 'gold' ? '💰' : '🍖';
                const bonusName = territory.bonusResource === 'gold' ? 'Or' : 'Nourriture';
                details += `<p style="color: #f39c12; font-weight: bold;">⭐ Bonus: +${territory.bonusAmount} ${bonusIcon} ${bonusName}/tour${revenueLabel}</p>`;
            }
            
            details += `<p>⚔️ Unités: ${territory.units?.length || 0}</p>`;
            
            document.getElementById('territory-details').innerHTML = details;
            
            // Afficher les unités
            updateUnitsList(territory);
            
            // Vérifier s'il faut afficher le panneau de construction (si un builder est sélectionné)
            checkBuilderSelected(territory);
        }
        
        // Fonction globale pour ouvrir la production depuis la base
        function openBaseProduction(territoryId) {
            const territory = gameData.territories[territoryId];
            if (territory && territory.base && territory.base.playerId === gameData.player.oderId) {
                const availableUnits = territory.base.canProduce || ['infantry', 'builder'];
                showProductionPanel(territoryId, availableUnits, '🏰 Base');
            }
        }
        
        // Fonction globale pour ouvrir la production depuis un bâtiment
        function openBuildingProduction(territoryId, buildingType) {
            const territory = gameData.territories[territoryId];
            const config = gameData.config.BUILDINGS[buildingType];
            if (territory && config && config.canProduce) {
                showProductionPanel(territoryId, config.canProduce, `${config.icon} ${config.name}`);
            }
        }
        
        // Vérifier si un builder est sélectionné pour afficher le panneau de construction
        function checkBuilderSelected(territory) {
            if (!territory || territory.team !== gameData.player.team) {
                return;
            }
            
            // Trouver un builder sélectionné
            const selectedBuilderUnit = territory.units?.find(u => 
                u.ownerId === gameData.player.oderId && 
                u.type === 'builder' && 
                selectedUnits.has(u.id)
            );
            
            if (selectedBuilderUnit) {
                // Un builder est sélectionné, afficher le panneau de construction
                showBuildPanel(selectedBuilderUnit, territory);
            } else {
                // Pas de builder sélectionné, réafficher le panneau de production si disponible
                updateLeftPanelForTerritory(territory);
            }
        }
        
        function updateUnitsList(territory) {
            const container = document.getElementById('units-container');
            container.innerHTML = '';
            
            if (!territory.units || territory.units.length === 0) {
                container.innerHTML = '<p style="color: #666;">Aucune unité</p>';
                return;
            }
            
            // Grouper les unités par propriétaire
            const myUnits = territory.units.filter(u => u.ownerId === gameData.player.oderId);
            const alliedUnits = territory.units.filter(u => u.team === gameData.player.team && u.ownerId !== gameData.player.oderId);
            const enemyUnits = territory.units.filter(u => u.team !== gameData.player.team);
            
            if (myUnits.length > 0) {
                container.innerHTML += '<p style="color: #4ecdc4; margin-bottom: 10px;">📍 Vos unités:</p>';
                myUnits.forEach(unit => {
                    const unitConfig = gameData.config.UNITS[unit.type];
                    const div = document.createElement('div');
                    div.className = `unit-item ${selectedUnits.has(unit.id) ? 'selected' : ''}`;
                    div.dataset.unitId = unit.id;
                    
                    // Affichage spécial pour l'artillerie avec rechargement
                    let extraInfo = '';
                    if (unit.type === 'artillery') {
                        const reloadEndTime = artilleryReloadTimes[unit.id];
                        if (reloadEndTime && Date.now() < reloadEndTime) {
                            const remaining = Math.ceil((reloadEndTime - Date.now()) / 1000);
                            extraInfo = `<span class="reload-indicator" style="font-size: 11px;"><span style="color: #f39c12;">⏱️${remaining}s</span></span>`;
                        } else {
                            extraInfo = `<span class="reload-indicator" style="font-size: 11px;"><span style="color: #27ae60;">✅ Prêt</span></span>`;
                        }
                    }
                    
                    div.innerHTML = `
                        <input type="checkbox" ${selectedUnits.has(unit.id) ? 'checked' : ''}>
                        <span style="font-size: 20px;">${unitConfig.icon}</span>
                        <span>${unitConfig.name}</span>
                        ${extraInfo}
                        <span style="margin-left: auto;">❤️${unit.health || unitConfig.health}</span>
                    `;
                    div.addEventListener('click', () => toggleUnitSelection(unit.id));
                    container.appendChild(div);
                });
            }
            
            if (alliedUnits.length > 0) {
                container.innerHTML += '<p style="color: var(--success); margin: 12px 0; font-family: Rajdhani, sans-serif; font-weight: 600;">🤝 Alliés: <span style="font-size: 12px; opacity: 0.7;">(' + alliedUnits.length + ')</span></p>';
                
                // Créer un conteneur scrollable pour les alliés
                const alliedContainer = document.createElement('div');
                alliedContainer.style.cssText = 'max-height: 130px; overflow-y: auto; border: 1px solid rgba(46, 204, 113, 0.4); border-radius: 10px; padding: 8px; margin-bottom: 12px; background: rgba(46, 204, 113, 0.05);';
                
                alliedUnits.forEach(unit => {
                    const unitConfig = gameData.config.UNITS[unit.type];
                    alliedContainer.innerHTML += `
                        <div class="unit-item" style="opacity: 0.8; padding: 8px; margin: 4px 0; border-radius: 8px; background: rgba(46, 204, 113, 0.1);">
                            <span style="font-size: 18px;">${unitConfig.icon}</span>
                            <span style="font-size: 13px; font-family: Rajdhani, sans-serif;">${unitConfig.name}</span>
                        </div>
                    `;
                });
                container.appendChild(alliedContainer);
            }
            
            if (enemyUnits.length > 0) {
                container.innerHTML += '<p style="color: var(--danger); margin: 12px 0; font-family: Rajdhani, sans-serif; font-weight: 600;">⚠️ Ennemis: <span style="font-size: 12px; opacity: 0.7;">(' + enemyUnits.length + ')</span></p>';
                
                // Créer un conteneur scrollable pour les ennemis
                const enemyContainer = document.createElement('div');
                enemyContainer.style.cssText = 'max-height: 130px; overflow-y: auto; border: 1px solid rgba(231, 76, 60, 0.4); border-radius: 10px; padding: 8px; background: rgba(231, 76, 60, 0.05);';
                
                enemyUnits.forEach(unit => {
                    const unitConfig = gameData.config.UNITS[unit.type];
                    enemyContainer.innerHTML += `
                        <div class="unit-item" style="border-color: rgba(231, 76, 60, 0.4); padding: 8px; margin: 4px 0; border-radius: 8px; background: rgba(231, 76, 60, 0.1);">
                            <span style="font-size: 18px;">${unitConfig.icon}</span>
                            <span style="font-size: 13px; font-family: Rajdhani, sans-serif;">${unitConfig.name}</span>
                        </div>
                    `;
                });
                container.appendChild(enemyContainer);
            }
            
            updateActionButtons();
        }
        
        // Mettre à jour l'affichage du rechargement périodiquement
        // Ne rafraîchit que le texte de rechargement, pas toute la liste
        setInterval(() => {
            if (selectedTerritory !== null) {
                const territory = gameData.territories[selectedTerritory];
                const hasArtillery = territory?.units?.some(u => u.type === 'artillery' && u.ownerId === gameData.player?.oderId);
                if (hasArtillery) {
                    // Mettre à jour seulement les indicateurs de rechargement sans reconstruire la liste
                    const container = document.getElementById('units-container');
                    const artilleryItems = container.querySelectorAll('.unit-item');
                    artilleryItems.forEach(item => {
                        const reloadSpan = item.querySelector('.reload-indicator');
                        if (reloadSpan) {
                            const unitId = item.dataset.unitId;
                            const reloadEndTime = artilleryReloadTimes[unitId];
                            if (reloadEndTime && Date.now() < reloadEndTime) {
                                const remaining = Math.ceil((reloadEndTime - Date.now()) / 1000);
                                reloadSpan.innerHTML = `<span style="color: #f39c12;">⏱️${remaining}s</span>`;
                            } else {
                                reloadSpan.innerHTML = `<span style="color: #27ae60;">✅ Prêt</span>`;
                            }
                        }
                    });
                }
            }
        }, 1000);
        
        function toggleUnitSelection(unitId) {
            if (selectedUnits.has(unitId)) {
                selectedUnits.delete(unitId);
            } else {
                selectedUnits.add(unitId);
            }
            
            if (selectedTerritory !== null) {
                const territory = gameData.territories[selectedTerritory];
                updateUnitsList(territory);
                checkBuilderSelected(territory);
            }
            updateActionButtons();
        }
        
        function updateActionButtons() {
            const moveBtn = document.getElementById('move-btn');
            const pathBtn = document.getElementById('path-btn');
            const attackBtn = document.getElementById('attack-btn');
            
            const hasSelectedUnits = selectedUnits.size > 0;
            moveBtn.disabled = !hasSelectedUnits;
            pathBtn.disabled = !hasSelectedUnits;
            attackBtn.disabled = !hasSelectedUnits;
            
            // Vérifier si artillerie sélectionnée pour changer le texte du bouton
            if (hasSelectedUnits && selectedTerritory !== null) {
                const territory = gameData.territories[selectedTerritory];
                const hasArtillery = Array.from(selectedUnits).some(unitId => {
                    const unit = territory.units?.find(u => u.id === unitId);
                    return unit && unit.type === 'artillery';
                });
                
                if (hasArtillery) {
                    const config = gameData.config.UNITS.artillery;
                    attackBtn.innerHTML = `💥 Tir d'artillerie (${config.range} cases, ${config.rangeAttack} DMG)`;
                } else {
                    attackBtn.innerHTML = '⚔️ Attaquer';
                }
            }
        }
        
        // ==================== BOUTONS D'ACTION ====================
        document.getElementById('move-btn').addEventListener('click', () => {
            if (selectedUnits.size === 0) return;
            
            moveMode = true;
            pathMode = false;
            artilleryMode = false;
            showNotification('🎯 Cliquez sur un territoire adjacent pour déplacer les unités');
            updateHighlightedTerritories();
        });
        
        document.getElementById('path-btn').addEventListener('click', () => {
            if (selectedUnits.size === 0) return;
            
            pathMode = true;
            moveMode = false;
            artilleryMode = false;
            currentPath = [selectedTerritory];
            showNotification('🗺️ Cliquez sur les territoires pour tracer le chemin. Clic droit pour confirmer.');
            updatePathDisplay();
        });
        
        document.getElementById('attack-btn').addEventListener('click', () => {
            if (selectedUnits.size === 0) return;
            
            // Vérifier si on a de l'artillerie sélectionnée
            const territory = gameData.territories[selectedTerritory];
            const hasArtillery = Array.from(selectedUnits).some(unitId => {
                const unit = territory.units?.find(u => u.id === unitId);
                return unit && unit.type === 'artillery';
            });
            
            if (hasArtillery) {
                // Mode artillerie longue portée
                artilleryMode = true;
                moveMode = false;
                pathMode = false;
                showNotification('💥 Artillerie: Cliquez sur un territoire ennemi à 2 cases de distance!');
                highlightArtilleryRange();
            } else {
                // Attaque normale adjacente
                moveMode = true;
                pathMode = false;
                artilleryMode = false;
                showNotification('⚔️ Cliquez sur un territoire adjacent ennemi pour attaquer!');
                updateHighlightedTerritories();
            }
        });
        
        function updateHighlightedTerritories() {
            document.querySelectorAll('.territory.can-move').forEach(el => el.classList.remove('can-move'));
            document.querySelectorAll('.territory.in-path').forEach(el => el.classList.remove('in-path'));
            document.querySelectorAll('.territory.in-range').forEach(el => el.classList.remove('in-range'));
            document.querySelectorAll('.path-marker').forEach(el => el.remove());
            
            if (moveMode && selectedTerritory !== null) {
                const territory = gameData.territories[selectedTerritory];
                territory.neighbors.forEach(neighborId => {
                    mapSvg.querySelector(`[data-id="${neighborId}"]`)?.classList.add('can-move');
                });
            }
        }
        
        // ==================== AFFICHAGE DES TROUPES EN MOUVEMENT ====================
        function updateMovingUnitsDisplay() {
            const panel = document.getElementById('moving-units-panel');
            const container = document.getElementById('moving-units-list');
            
            if (movingUnits.length === 0) {
                panel.classList.add('hidden');
                return;
            }
            
            panel.classList.remove('hidden');
            
            // Optimisation: construire le HTML en une seule fois
            const now = Date.now();
            const htmlParts = [];
            
            movingUnits.forEach(movement => {
                const elapsed = now - movement.startTime;
                const progress = Math.min(100, (elapsed / movement.totalTime) * 100);
                const remaining = Math.max(0, Math.ceil((movement.totalTime - elapsed) / 1000));
                
                const fromTerritory = gameData.territories[movement.path[0]];
                const toTerritory = gameData.territories[movement.path[movement.path.length - 1]];
                
                // Compter les unités par type
                const unitCounts = {};
                movement.units.forEach(u => {
                    unitCounts[u.type] = (unitCounts[u.type] || 0) + 1;
                });
                let unitText = '';
                Object.entries(unitCounts).forEach(([type, count]) => {
                    const icon = gameData.config.UNITS[type]?.icon || '⚔️';
                    unitText += `${icon}${count} `;
                });
                
                htmlParts.push(`
                    <div class="moving-item">
                        <div>${unitText.trim()}</div>
                        <div style="font-size: 12px; color: #888;">
                            ${fromTerritory?.name || '?'} → ${toTerritory?.name || '?'} (${remaining}s)
                        </div>
                        <div class="moving-progress">
                            <div class="moving-progress-bar" style="width: ${progress}%"></div>
                        </div>
                    </div>
                `);
            });
            
            container.innerHTML = htmlParts.join('');
        }
        
        // Mettre à jour l'affichage des troupes en mouvement (optimisé: 1000ms au lieu de 500ms)
        setInterval(updateMovingUnitsDisplay, 1000);
        
        // ==================== PRODUCTION ET CONSTRUCTION ====================
        let currentProductionTerritory = null; // Territoire de production sélectionné
        let selectedBuilder = null; // Builder sélectionné pour construction
        
        function initUnitButtons() {
            // Cette fonction est appelée au démarrage mais ne fait plus rien
            // Les boutons sont créés dynamiquement dans showProductionPanel
        }
        
        function showProductionPanel(territoryId, availableUnits, sourceName) {
            const container = document.getElementById('unit-buttons');
            container.innerHTML = '';
            
            currentProductionTerritory = territoryId;
            
            document.getElementById('production-title').textContent = `⚔️ Production - ${sourceName}`;
            document.getElementById('production-source-info').textContent = 
                `📍 Unités disponibles: ${availableUnits.join(', ')}`;
            
            availableUnits.forEach(type => {
                const config = gameData.config.UNITS[type];
                if (!config) return;
                
                const btn = document.createElement('button');
                btn.className = 'unit-btn';
                
                // Stats spéciales pour l'artillerie
                let statsHtml;
                if (type === 'artillery') {
                    statsHtml = `
                        <div class="unit-stats">
                            ⚔️Mêlée: ${config.attack} | 🎯Distance: ${config.rangeAttack} | 📏Portée: ${config.range} cases
                        </div>
                        <div class="unit-stats">
                            🛡️DEF: ${config.defense} | ❤️HP: ${config.health} | ⏱️Recharge: ${config.reloadTime/1000}s
                        </div>
                    `;
                } else if (type === 'builder') {
                    statsHtml = `
                        <div class="unit-stats">
                            🏗️ Peut construire des bâtiments
                        </div>
                        <div class="unit-stats">
                            ⚔️ATK: ${config.attack} | 🛡️DEF: ${config.defense} | ❤️HP: ${config.health}
                        </div>
                    `;
                } else {
                    statsHtml = `
                        <div class="unit-stats">
                            ⚔️ATK: ${config.attack} | 🛡️DEF: ${config.defense} | ❤️HP: ${config.health}
                        </div>
                    `;
                }
                
                btn.innerHTML = `
                    <div class="unit-header">
                        <span class="unit-name">${config.icon} ${config.name}</span>
                    </div>
                    <div class="unit-cost">💰${config.cost.gold} 🍖${config.cost.food}</div>
                    ${statsHtml}
                `;
                
                btn.disabled = gameData.player.resources.gold < config.cost.gold ||
                    gameData.player.resources.food < config.cost.food;
                    
                btn.addEventListener('click', () => produceUnit(type, territoryId));
                container.appendChild(btn);
            });
            
            document.getElementById('production-panel').classList.remove('hidden');
            document.getElementById('select-base-message').classList.add('hidden');
            document.getElementById('build-panel').classList.add('hidden');
        }
        
        function showBuildPanel(builder, territory) {
            selectedBuilder = builder;
            
            const container = document.getElementById('building-buttons');
            container.innerHTML = '';
            
            document.getElementById('builder-info').textContent = 
                `👷 Constructeur sur ${territory.name}`;
            
            Object.entries(gameData.config.BUILDINGS).forEach(([type, config]) => {
                const btn = document.createElement('button');
                btn.className = 'unit-btn';
                
                let productionInfo = '';
                if (config.canProduce) {
                    const units = config.canProduce.map(u => gameData.config.UNITS[u]?.icon || u).join(' ');
                    productionInfo = `<div class="unit-stats">🏭 Produit: ${units}</div>`;
                }
                if (config.attack) {
                    productionInfo = `<div class="unit-stats">⚔️ATK: ${config.attack} | 🛡️DEF: ${config.defense}</div>`;
                }
                
                btn.innerHTML = `
                    <div class="unit-header">
                        <span class="unit-name">${config.icon} ${config.name}</span>
                    </div>
                    <div class="unit-cost">💰${config.cost.gold} | ⏱️${config.buildTime/1000}s</div>
                    ${productionInfo}
                    <div class="unit-stats">❤️HP: ${config.health}</div>
                `;
                
                btn.disabled = gameData.player.resources.gold < config.cost.gold || builder.isBuilding;
                
                btn.addEventListener('click', () => buildStructure(builder.id, type, territory.id));
                container.appendChild(btn);
            });
            
            if (builder.isBuilding) {
                const remaining = Math.ceil((builder.buildingEndTime - Date.now()) / 1000);
                document.getElementById('builder-info').textContent = 
                    `👷 En construction... (${remaining}s)`;
            }
            
            document.getElementById('build-panel').classList.remove('hidden');
            document.getElementById('production-panel').classList.add('hidden');
            document.getElementById('select-base-message').classList.add('hidden');
        }
        
        function hideAllPanels() {
            document.getElementById('production-panel').classList.add('hidden');
            document.getElementById('build-panel').classList.add('hidden');
            if (gameData.player.hasBase) {
                document.getElementById('select-base-message').classList.remove('hidden');
            }
            currentProductionTerritory = null;
            selectedBuilder = null;
        }
        
        function produceUnit(unitType, territoryId) {
            const config = gameData.config.UNITS[unitType];
            if (gameData.player.resources.gold < config.cost.gold ||
                gameData.player.resources.food < config.cost.food) {
                showNotification('❌ Ressources insuffisantes!', 'error');
                return;
            }
            
            socket.emit('produce_unit', { unitType, territoryId });
        }
        
        function buildStructure(builderId, buildingType, territoryId) {
            const config = gameData.config.BUILDINGS[buildingType];
            if (gameData.player.resources.gold < config.cost.gold) {
                showNotification('❌ Or insuffisant!', 'error');
                return;
            }
            
            socket.emit('build_structure', { builderId, buildingType, territoryId });
        }
        
        // Calculer le revenu total par minute
        function calculateIncome() {
            if (!gameData.player || !gameData.territories) return { gold: 0, food: 0 };
            
            let goldPerTick = 0;
            let foodPerTick = 0;
            
            // Parcourir les territoires
            gameData.territories.forEach(t => {
                // 100% pour les territoires dont le joueur est propriétaire (gouverneur)
                if (t.owner === gameData.player.oderId) {
                    if (t.resources) {
                        goldPerTick += t.resources.gold || 0;
                        foodPerTick += t.resources.food || 0;
                    }
                    
                    if (t.bonusResource === 'gold' && t.bonusAmount) {
                        goldPerTick += t.bonusAmount;
                    } else if (t.bonusResource === 'food' && t.bonusAmount) {
                        foodPerTick += t.bonusAmount;
                    }
                    
                    // Production des bâtiments
                    if (t.buildings) {
                        t.buildings.forEach(building => {
                            if (building.ownerId === gameData.player.oderId) {
                                const config = gameData.config.BUILDINGS?.[building.type];
                                if (config && config.produces) {
                                    if (config.produces.gold) goldPerTick += config.produces.gold;
                                    if (config.produces.food) foodPerTick += config.produces.food;
                                }
                            }
                        });
                    }
                }
                // 50% pour les territoires de l'équipe dont le joueur n'est pas propriétaire
                else if (t.team === gameData.player.team && t.owner && t.owner !== gameData.player.oderId) {
                    if (t.resources) {
                        goldPerTick += (t.resources.gold || 0) * 0.5;
                        foodPerTick += (t.resources.food || 0) * 0.5;
                    }
                    
                    if (t.bonusResource === 'gold' && t.bonusAmount) {
                        goldPerTick += t.bonusAmount * 0.5;
                    } else if (t.bonusResource === 'food' && t.bonusAmount) {
                        foodPerTick += t.bonusAmount * 0.5;
                    }
                }
            });
            
            // Bonus de base si le joueur a une base
            if (gameData.player.hasBase) {
                goldPerTick += 20;
                foodPerTick += 10;
            }
            
            // Convertir en par minute (tick = 5 secondes, donc 12 ticks par minute)
            const ticksPerMinute = 60 / 5; // 12 ticks par minute
            return {
                gold: Math.round(goldPerTick * ticksPerMinute),
                food: Math.round(foodPerTick * ticksPerMinute)
            };
        }
        
        function updateResourcesDisplay() {
            document.getElementById('gold-value').textContent = Math.floor(gameData.player.resources.gold);
            document.getElementById('food-value').textContent = Math.floor(gameData.player.resources.food);
            
            // Mettre à jour le compteur d'unités
            const unitCount = countMyUnits();
            const maxUnits = gameData.config?.MAX_UNITS_PER_PLAYER || 20;
            const unitCountEl = document.getElementById('unit-count');
            if (unitCountEl) {
                unitCountEl.textContent = `${unitCount}/${maxUnits}`;
                // Rouge si proche de la limite
                if (unitCount >= maxUnits) {
                    unitCountEl.style.color = '#e74c3c';
                } else if (unitCount >= maxUnits * 0.8) {
                    unitCountEl.style.color = '#f39c12';
                } else {
                    unitCountEl.style.color = '#00f2fe';
                }
            }
            
            // Mettre à jour les revenus par minute
            const income = calculateIncome();
            const goldIncomeEl = document.getElementById('gold-income');
            const foodIncomeEl = document.getElementById('food-income');
            
            if (goldIncomeEl) {
                goldIncomeEl.textContent = `(+${income.gold}/min)`;
                goldIncomeEl.style.color = income.gold > 0 ? '#27ae60' : '#888';
            }
            if (foodIncomeEl) {
                foodIncomeEl.textContent = `(+${income.food}/min)`;
                foodIncomeEl.style.color = income.food > 0 ? '#27ae60' : '#888';
            }
        }
        
        // Compter mes unités
        function countMyUnits() {
            if (!gameData.player || !gameData.territories) return 0;
            let count = 0;
            
            // Unités sur les territoires
            gameData.territories.forEach(t => {
                if (t.units) {
                    count += t.units.filter(u => u.ownerId === gameData.player.oderId).length;
                }
            });
            
            // Unités en mouvement
            if (movingUnits) {
                count += movingUnits.filter(m => m.ownerId === gameData.player.oderId).length;
            }
            
            // Unités en production
            if (productionQueue) {
                count += productionQueue.length;
            }
            
            return count;
        }
        
        function updateProductionQueue() {
            const container = document.getElementById('queue-items');
            container.innerHTML = '';
            
            // Filtrer les productions terminées
            const now = Date.now();
            productionQueue = productionQueue.filter(item => item.endTime > now);
            
            productionQueue.forEach(item => {
                const config = gameData.config.UNITS[item.type];
                const elapsed = now - item.startTime;
                const total = item.endTime - item.startTime;
                const progress = Math.min(100, (elapsed / total) * 100);
                const remaining = Math.max(0, Math.ceil((item.endTime - now) / 1000));
                
                container.innerHTML += `
                    <div class="queue-item">
                        <span>${config.icon} ${config.name} (${remaining}s)</span>
                        <div class="queue-progress">
                            <div class="queue-progress-bar" style="width: ${progress}%"></div>
                        </div>
                    </div>
                `;
            });
            
            if (productionQueue.length === 0) {
                container.innerHTML = '<p style="color: #666; text-align: center;">Aucune production</p>';
            }
        }
        
        // Update production progress (optimisé: 500ms au lieu de 100ms)
        setInterval(updateProductionQueue, 500);
        
        // ==================== MISE À JOUR UI ====================
        function updateUI() {
            // Base message
            const baseMsg = document.getElementById('base-message');
            const selectBaseMsg = document.getElementById('select-base-message');
            const prodPanel = document.getElementById('production-panel');
            const buildPanel = document.getElementById('build-panel');
            
            if (gameData.player.hasBase) {
                baseMsg.classList.add('hidden');
                // Par défaut, montrer le message "cliquez sur votre base"
                if (!currentProductionTerritory && !selectedBuilder) {
                    selectBaseMsg.classList.remove('hidden');
                    prodPanel.classList.add('hidden');
                    buildPanel.classList.add('hidden');
                }
            } else {
                baseMsg.classList.remove('hidden');
                selectBaseMsg.classList.add('hidden');
                prodPanel.classList.add('hidden');
                buildPanel.classList.add('hidden');
            }
            
            updateResourcesDisplay();
            updateProductionButtons();
        }
        
        function updateProductionButtons() {
            // Mettre à jour les boutons de production si le panneau est visible
            if (currentProductionTerritory !== null) {
                document.querySelectorAll('#unit-buttons .unit-btn').forEach(btn => {
                    const unitName = btn.querySelector('.unit-name').textContent;
                    // Trouver le type d'unité
                    Object.entries(gameData.config.UNITS).forEach(([type, config]) => {
                        if (unitName.includes(config.name)) {
                            btn.disabled = gameData.player.resources.gold < config.cost.gold ||
                                gameData.player.resources.food < config.cost.food;
                        }
                    });
                });
            }
            
            // Mettre à jour les boutons de construction
            if (selectedBuilder) {
                document.querySelectorAll('#building-buttons .unit-btn').forEach(btn => {
                    const buildingName = btn.querySelector('.unit-name').textContent;
                    Object.entries(gameData.config.BUILDINGS).forEach(([type, config]) => {
                        if (buildingName.includes(config.name)) {
                            btn.disabled = gameData.player.resources.gold < config.cost.gold || selectedBuilder.isBuilding;
                        }
                    });
                });
            }
        }
        
        function updateTeamsDisplay() {
            document.getElementById('team-red-score').textContent = 
                `${gameData.teams.red?.territories || 0} territoires (${gameData.teams.red?.playerCount || 0} joueurs)`;
            document.getElementById('team-blue-score').textContent = 
                `${gameData.teams.blue?.territories || 0} territoires (${gameData.teams.blue?.playerCount || 0} joueurs)`;
            document.getElementById('team-green-score').textContent = 
                `${gameData.teams.green?.territories || 0} territoires (${gameData.teams.green?.playerCount || 0} joueurs)`;
            document.getElementById('team-yellow-score').textContent = 
                `${gameData.teams.yellow?.territories || 0} territoires (${gameData.teams.yellow?.playerCount || 0} joueurs)`;
        }
        
        // ==================== MINIMAP ====================
        function initMinimap() {
            const canvas = document.getElementById('minimap');
            canvas.width = 200;
            canvas.height = 140;
            updateMinimap();
            
            // Rendre la minimap cliquable pour navigation rapide
            const minimapCanvas = document.getElementById('minimap');
            minimapCanvas.style.cursor = 'pointer';
            
            minimapCanvas.addEventListener('click', (e) => {
                const rect = minimapCanvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                
                // Convertir les coordonnées minimap vers coordonnées carte
                const scaleX = 200 / MAP_WIDTH;
                const scaleY = 140 / MAP_HEIGHT;
                
                const mapX = clickX / scaleX;
                const mapY = clickY / scaleY;
                
                // Centrer la vue sur ce point
                const containerRect = mapContainer.getBoundingClientRect();
                mapState.offsetX = containerRect.width / 2 - mapX * mapState.scale;
                mapState.offsetY = containerRect.height / 2 - mapY * mapState.scale;
                
                updateMapTransform();
                updateMinimap();
            });
            
            // Permettre le drag sur la minimap
            let minimapDragging = false;
            
            minimapCanvas.addEventListener('mousedown', (e) => {
                minimapDragging = true;
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!minimapDragging) return;
                
                const rect = minimapCanvas.getBoundingClientRect();
                const clickX = Math.max(0, Math.min(200, e.clientX - rect.left));
                const clickY = Math.max(0, Math.min(140, e.clientY - rect.top));
                
                const scaleX = 200 / MAP_WIDTH;
                const scaleY = 140 / MAP_HEIGHT;
                
                const mapX = clickX / scaleX;
                const mapY = clickY / scaleY;
                
                const containerRect = mapContainer.getBoundingClientRect();
                mapState.offsetX = containerRect.width / 2 - mapX * mapState.scale;
                mapState.offsetY = containerRect.height / 2 - mapY * mapState.scale;
                
                updateMapTransform();
                updateMinimap();
            });
            
            document.addEventListener('mouseup', () => {
                minimapDragging = false;
            });
        }
        
        function updateMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#0a0a1e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const scaleX = canvas.width / MAP_WIDTH;
            const scaleY = canvas.height / MAP_HEIGHT;
            
            // Dessiner les territoires
            gameData.territories.forEach(t => {
                const x = t.centerX * scaleX;
                const y = t.centerY * scaleY;
                
                if (t.team === 'red') ctx.fillStyle = '#e74c3c';
                else if (t.team === 'blue') ctx.fillStyle = '#3498db';
                else if (t.team === 'green') ctx.fillStyle = '#27ae60';
                else if (t.team === 'yellow') ctx.fillStyle = '#f39c12';
                else ctx.fillStyle = '#3a3a5e';
                
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Marquer notre base avec un cercle doré
                if (t.base && gameData.player && (t.base.ownerId === gameData.player.oderId || t.base.playerId === gameData.player.oderId)) {
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });
            
            // Viewport
            const viewport = document.getElementById('minimap-viewport');
            const containerRect = mapContainer.getBoundingClientRect();
            
            const viewWidth = (containerRect.width / mapState.scale) * scaleX;
            const viewHeight = (containerRect.height / mapState.scale) * scaleY;
            const viewX = (-mapState.offsetX / mapState.scale) * scaleX;
            const viewY = (-mapState.offsetY / mapState.scale) * scaleY;
            
            viewport.style.width = `${Math.min(200, viewWidth)}px`;
            viewport.style.height = `${Math.min(140, viewHeight)}px`;
            viewport.style.left = `${Math.max(0, Math.min(200 - viewWidth, viewX))}px`;
            viewport.style.top = `${Math.max(0, Math.min(140 - viewHeight, viewY))}px`;
        }
        
        // ==================== CHAT ====================
        function initChat() {
            const input = document.getElementById('chat-input');
            const sendBtn = document.getElementById('chat-send');
            
            sendBtn.addEventListener('click', sendChatMessage);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendChatMessage();
            });
        }
        
        function sendChatMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();
            
            if (message) {
                socket.emit('chat_message', message);
                input.value = '';
            }
        }
        
        function addChatMessage(msg) {
            const container = document.getElementById('chat-messages');
            const teamColors = {
                red: '#e74c3c',
                blue: '#3498db',
                green: '#27ae60',
                yellow: '#f39c12'
            };
            
            container.innerHTML += `
                <div class="chat-msg">
                    <span class="author" style="color: ${teamColors[msg.team]}">${msg.author}:</span>
                    <span>${msg.message}</span>
                </div>
            `;
            
            container.scrollTop = container.scrollHeight;
        }
        
        // ==================== NOTIFICATIONS ====================
        function showNotification(message, type = 'info') {
            // Pas de notifications pour les spectateurs
            if (isSpectator) return;
            
            const container = document.getElementById('notifications');
            const notif = document.createElement('div');
            notif.className = `notification ${type}`;
            notif.textContent = message;
            container.appendChild(notif);
            
            setTimeout(() => notif.remove(), 4000);
        }
        
        // ==================== SYSTÈME DE COMBAT ANIMÉ ====================
        function startBattleAnimation(battleData) {
            console.log('Démarrage animation combat:', battleData);
            currentBattle = battleData;
            battleAnimationRunning = true;
            
            const modal = document.getElementById('battle-modal');
            const territoryName = document.getElementById('battle-territory-name');
            const attackerContainer = document.getElementById('attacker-units');
            const defenderContainer = document.getElementById('defender-units');
            const logContainer = document.getElementById('battle-log-entries');
            const resultDiv = document.getElementById('battle-result');
            const closeBtn = document.getElementById('battle-close-btn');
            const skipBtn = document.getElementById('battle-skip-btn');
            
            // Reset
            logContainer.innerHTML = '';
            resultDiv.classList.add('hidden');
            closeBtn.classList.add('hidden');
            skipBtn.classList.remove('hidden');
            
            // Titre territoire
            const territory = gameData.territories[battleData.territoryId];
            territoryName.textContent = `📍 ${territory?.name || 'Territoire inconnu'}`;
            
            // Afficher les armées avec leur vie
            renderBattleUnits(attackerContainer, battleData.attackers, 'attacker');
            renderBattleUnits(defenderContainer, battleData.defenders, 'defender');
            
            modal.classList.remove('hidden');
            
            // Jouer les rounds d'animation
            playBattleRounds(battleData.rounds, battleData.result);
        }
        
        function renderBattleUnits(container, units, side) {
            container.innerHTML = '';
            
            if (!units || units.length === 0) {
                container.innerHTML = '<p style="color: #666; text-align: center;">Aucune unité</p>';
                return;
            }
            
            units.forEach((unit, idx) => {
                const unitConfig = gameData.config.UNITS[unit.type];
                const maxHealth = unitConfig.health;
                const healthPercent = Math.max(0, (unit.health / maxHealth) * 100);
                const healthClass = healthPercent <= 25 ? 'critical' : healthPercent <= 50 ? 'low' : '';
                
                const div = document.createElement('div');
                div.className = 'battle-unit';
                div.id = `battle-unit-${side}-${idx}`;
                div.dataset.health = unit.health;
                div.dataset.maxHealth = maxHealth;
                div.innerHTML = `
                    <span class="unit-icon-large">${unitConfig.icon}</span>
                    <div class="unit-info">
                        <div class="unit-type-name">${unitConfig.name}</div>
                        <div class="unit-stats-battle">⚔️${unitConfig.attack} | 🛡️${unitConfig.defense}</div>
                    </div>
                    <div class="health-bar-wrapper">
                        <div class="health-bar-container">
                            <div class="health-bar ${healthClass}" style="width: ${healthPercent}%"></div>
                            <span class="health-text">${Math.round(unit.health)}/${maxHealth}</span>
                        </div>
                        <span class="health-value-outside ${healthClass}">❤️ ${Math.round(unit.health)}</span>
                    </div>
                `;
                container.appendChild(div);
            });
        }
        
        async function playBattleRounds(rounds, result) {
            const logContainer = document.getElementById('battle-log-entries');
            const skipBtn = document.getElementById('battle-skip-btn');
            let skipped = false;
            
            // Gestionnaire pour passer l'animation
            const skipHandler = () => {
                skipped = true;
            };
            skipBtn.addEventListener('click', skipHandler);
            
            for (let i = 0; i < rounds.length; i++) {
                if (skipped) break;
                
                const round = rounds[i];
                await animateSingleRound(round, logContainer, skipped ? 0 : 800);
                
                if (!skipped) {
                    await sleep(300);
                }
            }
            
            skipBtn.removeEventListener('click', skipHandler);
            
            // Afficher le résultat
            showBattleResult(result);
        }
        
        async function animateSingleRound(round, logContainer, delay) {
            const { attackerIdx, defenderIdx, attackerSide, damage, killed, attackerType, defenderType } = round;
            
            // Identifier les éléments
            const attackerElem = document.getElementById(`battle-unit-${attackerSide}-${attackerIdx}`);
            const defenderSide = attackerSide === 'attacker' ? 'defender' : 'attacker';
            const defenderElem = document.getElementById(`battle-unit-${defenderSide}-${defenderIdx}`);
            
            if (!attackerElem || !defenderElem) return;
            
            // Animation d'attaque
            attackerElem.classList.add('attacking');
            
            await sleep(delay / 2);
            
            // Animation de dégât
            defenderElem.classList.add('hit');
            
            // Mettre à jour la vie
            const currentHealth = parseFloat(defenderElem.dataset.health) - damage;
            const maxHealth = parseFloat(defenderElem.dataset.maxHealth);
            defenderElem.dataset.health = Math.max(0, currentHealth);
            
            const healthBar = defenderElem.querySelector('.health-bar');
            const healthText = defenderElem.querySelector('.health-text');
            const healthOutside = defenderElem.querySelector('.health-value-outside');
            const healthPercent = Math.max(0, (currentHealth / maxHealth) * 100);
            const displayHealth = Math.max(0, Math.round(currentHealth));
            
            healthBar.style.width = `${healthPercent}%`;
            healthText.textContent = `${displayHealth}/${Math.round(maxHealth)}`;
            healthOutside.textContent = `❤️ ${displayHealth}`;
            
            // Classes de couleur vie
            healthBar.classList.remove('low', 'critical');
            healthOutside.classList.remove('low', 'critical');
            if (healthPercent <= 25) {
                healthBar.classList.add('critical');
                healthOutside.classList.add('critical');
            } else if (healthPercent <= 50) {
                healthBar.classList.add('low');
                healthOutside.classList.add('low');
            }
            
            // Log
            const attackerConfig = gameData.config.UNITS[attackerType];
            const defenderConfig = gameData.config.UNITS[defenderType];
            const logEntry = document.createElement('div');
            logEntry.className = 'battle-log-entry';
            logEntry.innerHTML = `
                <span class="${attackerSide}-name">${attackerConfig.icon} ${attackerConfig.name}</span>
                attaque 
                <span class="${defenderSide}-name">${defenderConfig.icon} ${defenderConfig.name}</span>
                → <span class="damage">-${Math.round(damage)} HP</span>
                ${killed ? ' ☠️' : ''}
            `;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            await sleep(delay / 2);
            
            // Retirer les classes d'animation
            attackerElem.classList.remove('attacking');
            defenderElem.classList.remove('hit');
            
            // Si tué, marquer comme mort
            if (killed) {
                defenderElem.classList.add('dead');
            }
        }
        
        function showBattleResult(result) {
            const resultDiv = document.getElementById('battle-result');
            const resultTitle = document.getElementById('battle-result-title');
            const resultText = document.getElementById('battle-result-text');
            const closeBtn = document.getElementById('battle-close-btn');
            const skipBtn = document.getElementById('battle-skip-btn');
            
            resultDiv.classList.remove('hidden', 'victory', 'defeat');
            
            if (result.attackerWins) {
                resultDiv.classList.add('victory');
                resultTitle.textContent = '🏆 VICTOIRE !';
                resultText.textContent = `Territoire conquis! ${result.survivingAttackers} unités survivantes.`;
            } else {
                resultDiv.classList.add('defeat');
                resultTitle.textContent = '💀 DÉFAITE';
                resultText.textContent = `Attaque repoussée! ${result.survivingDefenders} défenseurs restants.`;
            }
            
            skipBtn.classList.add('hidden');
            closeBtn.classList.remove('hidden');
            
            // Fermer le modal
            closeBtn.onclick = () => {
                document.getElementById('battle-modal').classList.add('hidden');
                currentBattle = null;
                battleAnimationRunning = false;
            };
        }
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        // ==================== MARQUEURS D'UNITÉS EN MOUVEMENT SUR LA CARTE ====================
        // Cache des marqueurs pour éviter de les recréer à chaque frame
        const movingMarkersCache = new Map();
        
        function updateMovingMarkers() {
            const now = Date.now();
            
            // Récupérer les territoires visibles (pour le brouillard de guerre)
            const visibleTerritories = isSpectator ? null : getVisibleTerritories();
            
            // Marquer tous les marqueurs existants comme potentiellement à supprimer
            const activeIds = new Set();
            
            movingUnits.forEach(movement => {
                // Calculer la position actuelle
                const elapsed = now - movement.startTime;
                const stepProgress = (elapsed % movement.timePerTerritory) / movement.timePerTerritory;
                const currentStepIdx = Math.min(
                    movement.path.length - 2,
                    Math.floor(elapsed / movement.timePerTerritory)
                );
                
                if (currentStepIdx < 0 || currentStepIdx >= movement.path.length - 1) return;
                
                const fromTerritory = gameData.territories[movement.path[currentStepIdx]];
                const toTerritory = gameData.territories[movement.path[currentStepIdx + 1]];
                
                if (!fromTerritory || !toTerritory) return;
                
                // BROUILLARD DE GUERRE: Ne pas afficher les mouvements ennemis dans le brouillard
                if (!isSpectator && visibleTerritories) {
                    const isOurMovement = movement.units && movement.units.length > 0 && 
                                          movement.units[0].team === gameData.player.team;
                    
                    if (!isOurMovement) {
                        const fromVisible = visibleTerritories.has(fromTerritory.id);
                        const toVisible = visibleTerritories.has(toTerritory.id);
                        if (!fromVisible && !toVisible) return;
                    }
                }
                
                // Interpoler la position
                const x = fromTerritory.centerX + (toTerritory.centerX - fromTerritory.centerX) * stepProgress;
                const y = fromTerritory.centerY + (toTerritory.centerY - fromTerritory.centerY) * stepProgress;
                
                const markerId = movement.id || `${movement.path.join('-')}-${movement.startTime}`;
                activeIds.add(markerId);
                
                // Réutiliser ou créer le marqueur
                let marker = movingMarkersCache.get(markerId);
                if (!marker) {
                    marker = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    marker.setAttribute('class', 'moving-marker');
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('r', '80');
                    circle.setAttribute('fill', 'rgba(155, 89, 182, 0.3)');
                    circle.setAttribute('stroke', '#9b59b6');
                    circle.setAttribute('stroke-width', '4');
                    marker.appendChild(circle);
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('font-size', '60');
                    text.setAttribute('class', 'moving-marker-icon');
                    
                    // Compter les unités (une seule fois à la création)
                    const unitCounts = {};
                    movement.units.forEach(u => {
                        unitCounts[u.type] = (unitCounts[u.type] || 0) + 1;
                    });
                    let iconText = '';
                    Object.entries(unitCounts).forEach(([type, count]) => {
                        const icon = gameData.config.UNITS[type]?.icon || '⚔️';
                        iconText += `${icon}${count} `;
                    });
                    text.textContent = iconText.trim();
                    marker.appendChild(text);
                    
                    mapSvg.appendChild(marker);
                    movingMarkersCache.set(markerId, marker);
                }
                
                // Mettre à jour seulement la position (opération légère)
                marker.setAttribute('transform', `translate(${x}, ${y})`);
            });
            
            // Supprimer les marqueurs qui ne sont plus utilisés
            movingMarkersCache.forEach((marker, id) => {
                if (!activeIds.has(id)) {
                    marker.remove();
                    movingMarkersCache.delete(id);
                }
            });
        }
        
        // Mettre à jour les marqueurs régulièrement (optimisé: 250ms au lieu de 100ms)
        setInterval(updateMovingMarkers, 250);
        
        // ==================== PORTÉE ARTILLERIE ====================
        function getTerritoriesInRange(territoryId, range) {
            const visited = new Set([territoryId]);
            let frontier = [territoryId];
            const inRange = [];
            
            for (let depth = 1; depth <= range; depth++) {
                const nextFrontier = [];
                frontier.forEach(tId => {
                    const territory = gameData.territories[tId];
                    if (!territory) return;
                    
                    territory.neighbors.forEach(neighborId => {
                        if (!visited.has(neighborId)) {
                            visited.add(neighborId);
                            nextFrontier.push(neighborId);
                            inRange.push({ id: neighborId, distance: depth });
                        }
                    });
                });
                frontier = nextFrontier;
            }
            
            return inRange;
        }
        
        function highlightArtilleryRange() {
            // Retirer les anciens highlights
            document.querySelectorAll('.territory.in-range').forEach(el => el.classList.remove('in-range'));
            
            if (!artilleryMode || selectedTerritory === null) return;
            
            // Vérifier si on a de l'artillerie sélectionnée
            const territory = gameData.territories[selectedTerritory];
            const hasArtillery = Array.from(selectedUnits).some(unitId => {
                const unit = territory.units?.find(u => u.id === unitId);
                return unit && unit.type === 'artillery';
            });
            
            if (!hasArtillery) return;
            
            // Obtenir les territoires à portée (2 cases pour artillerie)
            const inRange = getTerritoriesInRange(selectedTerritory, 2);
            
            // Highlight uniquement les territoires ennemis
            inRange.forEach(({ id }) => {
                const t = gameData.territories[id];
                if (t && t.team && t.team !== gameData.player.team) {
                    mapSvg.querySelector(`[data-id="${id}"]`)?.classList.add('in-range');
                }
            });
        }
        
        // ==================== BROUILLARD DE GUERRE ====================
        function getVisibleTerritories() {
            const visible = new Set();
            
            // Vérification que le joueur existe
            if (!gameData.player || !gameData.player.team) {
                // Retourner tous les territoires si pas encore connecté
                gameData.territories?.forEach(t => visible.add(t.id));
                return visible;
            }
            
            const myTeam = gameData.player.team;
            
            // Calculer la portée de vision de base (territoires contrôlés + voisins)
            let visionRange = 1;
            if (playerTechnologies.improvedVision) visionRange = 2;
            
            gameData.territories.forEach(t => {
                // Les territoires de notre équipe sont toujours visibles
                if (t.team === myTeam) {
                    visible.add(t.id);
                    
                    // Ajouter les voisins dans la portée de vision
                    let frontier = [t.id];
                    const visited = new Set([t.id]);
                    
                    for (let depth = 0; depth < visionRange; depth++) {
                        const nextFrontier = [];
                        frontier.forEach(tId => {
                            const territory = gameData.territories[tId];
                            if (!territory) return;
                            territory.neighbors.forEach(neighborId => {
                                if (!visited.has(neighborId)) {
                                    visited.add(neighborId);
                                    visible.add(neighborId);
                                    nextFrontier.push(neighborId);
                                }
                            });
                        });
                        frontier = nextFrontier;
                    }
                }
                
                // Les éclaireurs révèlent plus loin
                if (t.units) {
                    t.units.forEach(unit => {
                        if (unit.type === 'scout' && unit.ownerId === gameData.player.oderId) {
                            const scoutVision = gameData.config.UNITS.scout?.visionRange || 3;
                            let frontier = [t.id];
                            const visited = new Set([t.id]);
                            visible.add(t.id);
                            
                            for (let depth = 0; depth < scoutVision; depth++) {
                                const nextFrontier = [];
                                frontier.forEach(tId => {
                                    const territory = gameData.territories[tId];
                                    if (!territory) return;
                                    territory.neighbors.forEach(neighborId => {
                                        if (!visited.has(neighborId)) {
                                            visited.add(neighborId);
                                            visible.add(neighborId);
                                            nextFrontier.push(neighborId);
                                        }
                                    });
                                });
                                frontier = nextFrontier;
                            }
                        }
                    });
                }
            });
            
            return visible;
        }
        
        // Cache des polygons pour éviter les querySelector répétés
        let polygonCache = new Map();
        
        function getPolygonById(id) {
            if (!polygonCache.has(id)) {
                const polygon = mapSvg.querySelector(`[data-id="${id}"]`);
                if (polygon) polygonCache.set(id, polygon);
                return polygon;
            }
            return polygonCache.get(id);
        }
        
        function clearPolygonCache() {
            polygonCache.clear();
        }
        
        function updateFogOfWar() {
            // Les spectateurs voient toute la carte
            if (isSpectator) {
                gameData.territories.forEach(t => {
                    const polygon = getPolygonById(t.id);
                    if (polygon) polygon.classList.remove('fog');
                    // Montrer tous les marqueurs
                    mapSvg.querySelectorAll(`[data-territory="${t.id}"]`).forEach(el => {
                        el.style.display = '';
                    });
                });
                return;
            }
            
            const visible = getVisibleTerritories();
            
            gameData.territories.forEach(t => {
                const polygon = getPolygonById(t.id);
                if (!polygon) return;
                
                const isVisible = visible.has(t.id);
                
                if (isVisible) {
                    polygon.classList.remove('fog');
                } else {
                    polygon.classList.add('fog');
                }
                
                // Cacher/montrer les marqueurs (noms, unités, bâtiments, terrain, etc.)
                mapSvg.querySelectorAll(`[data-territory="${t.id}"]`).forEach(el => {
                    el.style.display = isVisible ? '' : 'none';
                });
            });
        }
        
        // Mettre à jour le brouillard périodiquement (optimisé: 3000ms au lieu de 2000ms)
        setInterval(updateFogOfWar, 3000);
        
        // ==================== ANIMATIONS D'EXPLOSION SUR LA CARTE ====================
        function showExplosionOnMap(territoryId) {
            const territory = gameData.territories[territoryId];
            if (!territory) return;
            
            const explosion = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            explosion.setAttribute('x', territory.centerX);
            explosion.setAttribute('y', territory.centerY);
            explosion.setAttribute('text-anchor', 'middle');
            explosion.setAttribute('font-size', '120');
            explosion.setAttribute('class', 'explosion-marker');
            explosion.textContent = '💥';
            mapSvg.appendChild(explosion);
            
            // Supprimer après l'animation
            setTimeout(() => explosion.remove(), 500);
        }
        
        // ==================== LEADERBOARD TOGGLE ====================
        let leaderboardVisible = false;
        
        function toggleLeaderboard() {
            leaderboardVisible = !leaderboardVisible;
            const leaderboard = document.getElementById('leaderboard');
            const toggleBtn = document.getElementById('leaderboard-toggle');
            
            if (leaderboardVisible) {
                leaderboard.classList.remove('collapsed');
                toggleBtn.classList.add('active');
                toggleBtn.textContent = '✓ Classement';
            } else {
                leaderboard.classList.add('collapsed');
                toggleBtn.classList.remove('active');
                toggleBtn.textContent = '🏆 Classement';
            }
        }
        
        // ==================== MODAL JOUEURS CONNECTÉS ====================
        let playersModalVisible = false;
        
        function togglePlayersModal() {
            playersModalVisible = !playersModalVisible;
            const modal = document.getElementById('players-modal');
            
            if (playersModalVisible) {
                modal.classList.remove('hidden');
                updatePlayersModal();
            } else {
                modal.classList.add('hidden');
            }
        }
        
        function updatePlayersModal() {
            if (!playersModalVisible || !gameData.teams) return;
            
            const teams = ['red', 'blue', 'green', 'yellow'];
            const teamNames = {
                red: 'Rouge',
                blue: 'Bleue',
                green: 'Verte',
                yellow: 'Jaune'
            };
            
            teams.forEach(team => {
                const playersList = document.getElementById(`${team}-players-list`);
                const teamStats = document.getElementById(`${team}-team-stats`);
                const teamData = gameData.teams[team];
                
                if (!teamData || !teamData.players || teamData.players.length === 0) {
                    playersList.innerHTML = '<div class="no-players">Aucun joueur dans cette équipe</div>';
                    teamStats.textContent = '0 joueurs | 0 territoires';
                    return;
                }
                
                // Compter les territoires de l'équipe
                const teamTerritories = gameData.territories.filter(t => t.owner === team).length;
                
                // Séparer joueurs humains et IA pour le comptage
                const humanCount = teamData.players.filter(p => !p.isAI).length;
                const aiCount = teamData.players.filter(p => p.isAI).length;
                
                let statsText = '';
                if (humanCount > 0 && aiCount > 0) {
                    statsText = `${humanCount} humain${humanCount > 1 ? 's' : ''} + ${aiCount} IA | ${teamTerritories} terr.`;
                } else if (aiCount > 0) {
                    statsText = `${aiCount} IA | ${teamTerritories} territoires`;
                } else {
                    statsText = `${humanCount} joueur${humanCount > 1 ? 's' : ''} | ${teamTerritories} territoires`;
                }
                teamStats.textContent = statsText;
                
                // Générer la liste des joueurs
                let html = '';
                
                // Séparer joueurs humains et IA
                const humanPlayers = teamData.players.filter(p => !p.isAI);
                const aiPlayers = teamData.players.filter(p => p.isAI);
                
                // Afficher d'abord les humains
                humanPlayers.forEach(player => {
                    const isMe = gameData.player && player.oderId === gameData.player.oderId;
                    const hasBase = player.hasBase;
                    
                    // Compter les unités du joueur
                    let unitCount = 0;
                    let territoryCount = 0;
                    
                    gameData.territories.forEach(t => {
                        if (t.units) {
                            unitCount += t.units.filter(u => u.ownerId === player.oderId).length;
                        }
                        // Compter les territoires où le joueur a sa base
                        if (t.base && t.base.ownerId === player.oderId) {
                            territoryCount++;
                        }
                    });
                    
                    html += `
                        <div class="player-row ${isMe ? 'me' : ''} ${hasBase ? 'has-base' : ''}">
                            <div class="player-info">
                                <span class="player-name">${isMe ? '👤 ' : ''}${player.name}</span>
                                <span class="player-status ${hasBase ? '' : 'no-base'}">${hasBase ? '🏰 Base active' : '❌ Pas de base'}</span>
                            </div>
                            <div class="player-stats">
                                <span class="player-stat">🎖️ ${unitCount} unités</span>
                                <span class="player-stat">💰 ${player.resources?.gold || 0}</span>
                                <span class="player-stat">🍖 ${player.resources?.food || 0}</span>
                            </div>
                        </div>
                    `;
                });
                
                // Afficher ensuite les IA
                aiPlayers.forEach(player => {
                    const hasBase = player.hasBase;
                    
                    // Compter les unités du joueur IA
                    let unitCount = 0;
                    gameData.territories.forEach(t => {
                        if (t.units) {
                            unitCount += t.units.filter(u => u.ownerId === player.oderId).length;
                        }
                    });
                    
                    // Style d'IA traduit
                    const aiStyleNames = {
                        aggressive: '🔥 Agressif',
                        defensive: '🛡️ Défensif',
                        economic: '💰 Économique',
                        balanced: '⚖️ Équilibré',
                        rusher: '⚡ Rusher',
                        turtler: '🐢 Turtle',
                        tech: '🔧 Technicien',
                        swarm: '🐜 Essaim',
                        opportunist: '🎯 Opportuniste',
                        sniper: '🏹 Sniper'
                    };
                    const styleText = aiStyleNames[player.aiStyle] || '🤖 IA';
                    
                    html += `
                        <div class="player-row ai-player ${hasBase ? 'has-base' : ''}" style="opacity: 0.85; border-left: 3px solid #9b59b6;">
                            <div class="player-info">
                                <span class="player-name">🤖 ${player.name}</span>
                                <span class="player-status" style="background: rgba(155, 89, 182, 0.3); color: #bb86fc;">${styleText}</span>
                            </div>
                            <div class="player-stats">
                                <span class="player-stat">🎖️ ${unitCount} unités</span>
                                <span class="player-stat">${hasBase ? '🏰' : '❌'}</span>
                            </div>
                        </div>
                    `;
                });
                
                playersList.innerHTML = html;
            });
        }
        
        // Mettre à jour le modal périodiquement si ouvert
        setInterval(() => {
            if (playersModalVisible) {
                updatePlayersModal();
            }
        }, 2000);
        
        // ==================== TOGGLE SON ====================
        function toggleSound() {
            soundEnabled = !soundEnabled;
            const btn = document.getElementById('sound-toggle');
            
            if (soundEnabled) {
                btn.textContent = '🔊 Son';
                btn.classList.remove('muted');
                showNotification('🔊 Sons activés');
            } else {
                btn.textContent = '🔇 Son';
                btn.classList.add('muted');
                showNotification('🔇 Sons désactivés');
            }
        }
        
        // ==================== DRAPEAUX ANIMÉS ====================
        function updateFlags() {
            // Supprimer les anciens drapeaux
            document.querySelectorAll('.flag-marker').forEach(el => el.remove());
            
            // Obtenir les territoires visibles pour le brouillard
            const visibleTerritories = isSpectator ? null : getVisibleTerritories();
            
            // Ajouter des drapeaux animés sur les territoires avec base
            gameData.territories.forEach(t => {
                if (t.team && t.base) {
                    // Créer un groupe pour le drapeau
                    const flagGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    flagGroup.setAttribute('class', 'flag-marker');
                    flagGroup.setAttribute('data-territory', t.id);
                    flagGroup.setAttribute('transform', `translate(${t.centerX + 80}, ${t.centerY - 100})`);
                    
                    // Cacher si dans le brouillard
                    if (visibleTerritories && !visibleTerritories.has(t.id)) {
                        flagGroup.style.display = 'none';
                    }
                    
                    // Mât du drapeau
                    const pole = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    pole.setAttribute('x1', '0');
                    pole.setAttribute('y1', '0');
                    pole.setAttribute('x2', '0');
                    pole.setAttribute('y2', '60');
                    pole.setAttribute('stroke', '#8B4513');
                    pole.setAttribute('stroke-width', '4');
                    pole.setAttribute('stroke-linecap', 'round');
                    flagGroup.appendChild(pole);
                    
                    // Drapeau (tissu) avec couleur de l'équipe
                    const teamColors = {
                        red: '#e74c3c',
                        blue: '#3498db',
                        green: '#27ae60',
                        yellow: '#f39c12'
                    };
                    
                    const flag = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    flag.setAttribute('d', 'M0,5 Q20,-5 40,5 Q20,15 0,5 L0,25 Q20,35 40,25 Q20,15 0,25 Z');
                    flag.setAttribute('fill', teamColors[t.team] || '#888');
                    flag.setAttribute('stroke', 'rgba(0,0,0,0.3)');
                    flag.setAttribute('stroke-width', '1');
                    flag.style.transformOrigin = '0 15px';
                    flag.style.animation = `flagClothWave ${1.5 + Math.random() * 0.5}s ease-in-out infinite`;
                    flagGroup.appendChild(flag);
                    
                    mapSvg.appendChild(flagGroup);
                }
            });
        }
        
        // ==================== INDICATEURS BONUS RESSOURCES ====================
        function updateBonusMarkers() {
            // Supprimer les anciens marqueurs
            document.querySelectorAll('.bonus-marker').forEach(el => el.remove());
            
            // Obtenir les territoires visibles pour le brouillard
            const visibleTerritories = isSpectator ? null : getVisibleTerritories();
            
            // Ajouter des marqueurs sur les territoires avec bonus
            gameData.territories.forEach(t => {
                if (t.bonusResource) {
                    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    marker.setAttribute('x', t.centerX + 120);
                    marker.setAttribute('y', t.centerY + 40);
                    marker.setAttribute('text-anchor', 'middle');
                    marker.setAttribute('font-size', '40');
                    marker.setAttribute('class', 'bonus-marker');
                    marker.setAttribute('data-territory', t.id);
                    marker.textContent = t.bonusResource === 'gold' ? '💰' : '🍖';
                    
                    // Cacher si dans le brouillard
                    if (visibleTerritories && !visibleTerritories.has(t.id)) {
                        marker.style.display = 'none';
                    }
                    
                    mapSvg.appendChild(marker);
                }
            });
        }
        
        // ==================== INDICATEURS DE DIRECTION POUR TROUPES ====================
        // Cache des flèches de direction
        const directionArrowsCache = new Map();
        
        function updateDirectionArrows() {
            const now = Date.now();
            const activeIds = new Set();
            
            movingUnits.forEach(movement => {
                const elapsed = now - movement.startTime;
                const currentStepIdx = Math.min(
                    movement.path.length - 2,
                    Math.floor(elapsed / movement.timePerTerritory)
                );
                
                if (currentStepIdx < 0 || currentStepIdx >= movement.path.length - 1) return;
                
                const fromTerritory = gameData.territories[movement.path[currentStepIdx]];
                const toTerritory = gameData.territories[movement.path[currentStepIdx + 1]];
                
                if (!fromTerritory || !toTerritory) return;
                
                // Calculer l'angle de direction
                const dx = toTerritory.centerX - fromTerritory.centerX;
                const dy = toTerritory.centerY - fromTerritory.centerY;
                const angle = Math.atan2(dy, dx) * (180 / Math.PI);
                
                // Position intermédiaire
                const stepProgress = (elapsed % movement.timePerTerritory) / movement.timePerTerritory;
                const x = fromTerritory.centerX + dx * stepProgress;
                const y = fromTerritory.centerY + dy * stepProgress;
                
                const arrowId = movement.id || `${movement.path.join('-')}-${movement.startTime}`;
                activeIds.add(arrowId);
                
                // Réutiliser ou créer la flèche
                let arrow = directionArrowsCache.get(arrowId);
                if (!arrow) {
                    arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    const arrowSize = 30;
                    arrow.setAttribute('points', `${arrowSize},0 ${-arrowSize/2},${arrowSize/2} ${-arrowSize/2},${-arrowSize/2}`);
                    arrow.setAttribute('class', 'direction-arrow');
                    mapSvg.appendChild(arrow);
                    directionArrowsCache.set(arrowId, arrow);
                }
                
                // Mettre à jour seulement la position
                arrow.setAttribute('transform', `translate(${x}, ${y - 100}) rotate(${angle})`);
            });
            
            // Supprimer les flèches obsolètes
            directionArrowsCache.forEach((arrow, id) => {
                if (!activeIds.has(id)) {
                    arrow.remove();
                    directionArrowsCache.delete(id);
                }
            });
        }
        
        // Mettre à jour les indicateurs de direction (optimisé: 500ms au lieu de 200ms)
        setInterval(updateDirectionArrows, 500);
        
        // Mettre à jour les bonus après chaque mise à jour de territoire
        setInterval(() => {
            // updateFlags(); // Désactivé - drapeaux supprimés
            updateBonusMarkers();
            // Réappliquer le brouillard immédiatement après pour éviter le clignotement
            updateFogOfWar();
        }, 5000);
    </script>
</body>
</html>
